{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Hi there! Welcome to MDE Docs.</p> <p>Model Driven Engineering (MDE) is a methodology that primarily makes use of software models to carry out a software development process. Well-defined models are used to specify, validate, design, and implement complete software systems. Simply put, models undergo transformations to produce software. </p> <p>This website is meant to provide comprehensive documentation on MDE concepts, notations, process and rules, and tools for users of all skill levels. The main aim of this project is to introduce MDE to new users and provide extensive support for field experts in a clear format from a non-technical perspective. Another important objective is to document 3 projects of varying skill levels: a basic example for beginners, a complex example for improved understanding and an industry level project for expert use.</p> <p>Model transformations lie at the core of MDE but it is only one of the tools used in the software development process. Tools that automate tasks such as model-to-text transformations, model comparison, model validation and merging are also required. Some of these tools, model transformation languages (MTLs) in particular, are documented within this website. Namely, Epsilon Transformation Language (ETL) and Yet Another Model Transformation Language (YAMTL) have been thoroughly described.</p> <p>This site comprises of well-researched MDE concepts and tools that have not yet been widely adopted. After reading the docs, we hope the users see the benefit of automated code generation and syntactically well-defined programs that are applicable to a diverse range of use cases.</p>"},{"location":"epsilon.html","title":"Eclipse Epsilon","text":"<p>Epsilon is a family of scripting languages and tools for automating common model-based software engineering tasks such as code generation, model-to-model transformation, model validation and model visualisation, that work out of the box with EMF, UML, Simulink, XML and other types of models.</p> <p>Epsilon can be used as a standard Java library, and also provides Apache Ant tasks that can be embedded in Maven/Gradle builds. Editing support for Epsilon programs is available in Eclipse, VS Code and Sublime.</p>"},{"location":"epsilon.html#installation","title":"Installation","text":""},{"location":"epsilon.html#method-1-eclipse-marketplace-recommended","title":"Method 1: (Eclipse Marketplace - Recommended)","text":"<p>The best and quickest way to install the latest version of Epsilon is through the Eclipse Marketplace. To do this head over to <code>Help \u2192 Eclipse Marketplace</code> </p> <p></p>"},{"location":"epsilon.html#method-2-update-sites","title":"Method 2: (Update Sites)","text":"<p>You can also use one of the following update sites through the <code>Help \u2192 Install new software</code> menu in Eclipse to install (parts of) Epsilon. Enter one of the links below in the <code>Work with:</code> field and tick all the options (Epsilon Core artifact is required). Then click <code>Next \u2192 Finish</code> to install Epsilon on your Eclipse platform.</p> Site Location Stable (recommended) <code>http://download.eclipse.org/epsilon/updates/2.4/</code> Interim <code>http://download.eclipse.org/epsilon/interim/</code> <p></p>"},{"location":"epsilon.html#method-3-eclipse-marketplace-website","title":"Method 3: (Eclipse Marketplace website)","text":"<p>Another way is to head over to the Eclipse Marketplace site. Drag and drop the install button into your Eclipse IDE and finish the installation.</p> <p></p>"},{"location":"etl.html","title":"ETL","text":"<p>Epsilon's core is the general purpose model management language called Epsilon Object Language (EOL). EOL is meant to be reused in task specific languages. One such language is Epsilon Transformation Language (ETL) which is used to perform model-to-model transformations. ETL is a hybrid of declarative and imperative paradigms. It provides abstract rule-based execution of tasks as well as imperative EOL features to handle various transformation needs. ETL can be used to transform an arbitrary number of input models into a arbitrary number of output models of different modelling languages and technologies in a rule-based and modular manner.</p>"},{"location":"etl.html#project-structure","title":"Project Structure","text":"<p>An ETL model-to-model transformation project (see image below) requires a source model, source metamodel, target metamodel, an ETL program that contains the rules and transformations between the source and target model, and a build file which loads all EMF models and runs the ETL program to generate the target model (an XMI file in this case). </p> <p> </p> File structure of an example ETL project"},{"location":"etl.html#installation","title":"Installation","text":"<p>To use ETL, you just need to install Epsilon on Eclipse.</p>"},{"location":"etl.html#etl-basics","title":"ETL Basics","text":"<p>Before you get started on your own ETL project, let's introduce the basics of ETL through the syntax and semantics.</p>"},{"location":"etl.html#abstract-syntax","title":"Abstract Syntax","text":"<p><pre><code>classDiagram\nclass TransformRule {\n    -name: String\n    -abstract: Boolean\n    -lazy: Boolean\n    -primary: Boolean\n    -greedy: Boolean\n    -type: EolModelElementType\n    -guard: ExecutableBlock&lt;Boolean&gt;\n    -body: ExecutableBlock&lt;Void&gt;\n}\nclass Parameter {\n    -name: String\n    -type: EolType \n}\nclass NamedStatementBlockRule {\n    -name: String\n    -body: StatementBlock\n}\nEolModule &lt;|-- ErlModule\nEtlModule --|&gt; ErlModule\nPre --|&gt; NamedStatementBlockRule\nPost --|&gt; NamedStatementBlockRule\nErlModule -- Pre: pre *\nErlModule -- Post: post *\nEtlModule -- TransformRule: rules *\nTransformRule -- Parameter: source\nTransformRule -- Parameter: targets *\nTransformRule -- TransformRule: extends *</code></pre> </p> ETL constructs and relationships <p>The figure above represents ETL at a high level. In ETL, modules represent the model transformations. <code>EtlModule</code> can have one or more transformation rules (<code>TransformRule</code>). </p> <p>Each <code>TransformRule</code> provides a mapping between a <code>source</code> model parameter and <code>target</code> model parameter(s). It has some important characteristics:</p> <ul> <li>The name of a rule is unique within the context of a module.</li> <li>Each rule has only one <code>source</code> parameter and can have one or more <code>target</code> parameters.</li> <li>A transformation rule can <code>extend</code> other rules.</li> <li>You can declare a rule as <code>abstract</code>, <code>primary</code> and/or <code>lazy</code> (explained in the next section).</li> <li>An optional 'guard' selection statement can be defined to filter only certain elements (of specific attributes) that conform to the type of the <code>source</code> parameter.</li> <li>Each rule has a <code>body</code>. This is a block of EOL statements where the logic for assigning field values of target model is imperatively defined.</li> </ul> <p>ETL also allows users to declare <code>pre</code> and <code>post</code> blocks which are executed before and after the transformation rules.</p> <p>Warning</p> <p>These <code>pre</code> and <code>post</code> blocks are different to the pre-/post-condition annotations available for EOL user-defined operations</p>"},{"location":"etl.html#concrete-syntax","title":"Concrete Syntax","text":"<p>The basic format of an ETL document is as follows: </p> <p><pre><code>rule &lt;name&gt;\n    transform &lt;sourceParameterName&gt;:&lt;sourceParameterType&gt;\n    to &lt;targetParameterName&gt;:&lt;targetParameterType&gt;\n        (,&lt;targetParameterName&gt;:&lt;targetParameterType&gt;)* {\n\n    //Transformation rule body is comprised of EOL statement(s)\n    statement+\n\n}\n</code></pre> Note: &lt;&gt; is meant to show user-definable fields and is not part of the actual syntax</p> <p>Name of a <code>rule</code> is uniquely identified within an ETL module and it can contain numbers from 0-9. All contents in a rule's scope are indented. <code>transform</code> statement requires the name and type of the <code>source</code> parameter. <code>to</code> statement requires the name and type of the <code>target</code> parameter. There can be multiple target parameters which are each separated using comma (,). Curly braces ({}) just after the <code>to</code> statement defines the scope of the rule's <code>body</code>. The body comprises of EOL statement(s) that can assign attribute values to <code>target</code> model elements.</p> <p>ETL can also have optional attributes and statements that increase usability of the tool. The options are structured in the following manner:</p> <pre><code>(@abstract)?\n(@lazy)?\n(@primary)?\nrule &lt;name&gt;\n    transform &lt;sourceParameterName&gt;:&lt;sourceParameterType&gt;\n    to &lt;targetParameterName&gt;:&lt;targetParameterType&gt;\n        (,&lt;targetParameterName&gt;:&lt;targetParameterType&gt;)*\n    (extends &lt;ruleName&gt; (, &lt;ruleName&gt;*)? {\n\n    (guard (:expression)|({statementBlock}))?\n\n    statement+\n}\n</code></pre> <p>Note: (option)? is meant to show optional fields and is not part of the actual syntax</p> <p><code>@abstract</code>, <code>@lazy</code> and <code>@primary</code> optional attributes of a rule are defined on the line prior to the <code>rule</code> keyword. <code>@abstract</code> is used to declare rules that will be extended using the programming concept of inheritance. Rules declared as <code>@lazy</code> are executed after all the non-lazy rules have been executed. Results of the <code>equivalents()</code> operation can be prioritized (ordered) using rules that are declared<code>@primary</code>. Meaning, results of primary rules precede the results of all the other rules.</p> <p>A rule can extend one or more rules using the <code>extends</code> keyword after the <code>to</code> statement. Multiple extended rules form a comma-separated list.</p> <p>An optional <code>guard</code> is a type of filter or a selection statement which is declared in the curly braces ({}) that contains a rule's <code>body</code>. A simple guard is an EOL expression following a column (:) and a complex guard is a block of EOL statements enclosed in curly braces ({}).</p> <p>Apart from rules, ETL also includes <code>pre</code> and <code>post</code> blocks of EOL statements. The syntax for them is the keyword identifier as <code>pre</code> or <code>post</code>, followed by an optional name and a set of EOL statements enclosed in curly braces ({}).</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"etl.html#execution-semantics","title":"Execution Semantics","text":""},{"location":"etl.html#rule-and-block-overriding","title":"Rule and Block Overriding","text":"<p>Users can import other ETL modules within an ETL module. The importing ETL module (containing <code>import</code> keyword) inherits all the rules and pre/post blocks specified in the modules it imports (recursively).</p> <p>If the importing module specifies a rule or pre/post block with the same name as one from the imported module, then the local rule/block is prioritised and it overrides the imported one.</p>"},{"location":"etl.html#execution-scheduling","title":"Execution Scheduling","text":"<p><pre><code>graph LR\n    A[pre block] --&gt; B[rules];\n    B --&gt; C[post block];</code></pre> </p> Flow of statement execution <p>When an ETL module is executed, the <code>pre</code> blocks are executed first. If there are multiple <code>pre</code> blocks, then they are executed sequentially in the order defined.</p> <p>Next, each non-abstract and non-lazy <code>rule</code> is executed for all elements on which the rule is applicable. To be applicable to a particular element, the element must have a type-of relationship (<code>sourceParameter</code> fields must be filled) or a kind-of relationship (if the <code>rule</code> is annotated as <code>@greedy</code>). Additionally, the element must satisfy the <code>guard</code> of the rule (and all rules it extends). Then the <code>@abstract</code> and  <code>@lazy</code> rules are executed in order.</p> <p>After all rules have been executed, the <code>post</code> blocks are executed in the order they have been specified.</p>"},{"location":"etl.html#source-element-resolution","title":"Source Element Resolution","text":"<p>Resolving source elements is a common task in the execution of a rule and this has been automated by ETL. This also helps in reducing coupling between different rules and keeps the mappings between source and target elements clear. ETL contains <code>equivalent()</code> and <code>equivalents()</code> built-in operations that automatically resolve source elements to the corresponding target elements.</p> <p><code>equivalents()</code> operation:</p> <p><code>equivalents()</code> operation has different behaviors when applied to a single source element or a collection of elements. When applied on a single element, the operation inspects the transformation trace (see figure below) and invokes applicable rules (if necessary) to calculate the target element. When the operation is applied on a collection, a <code>Bag</code> containing <code>Bag</code>s that contain the corresponding target elements of the original source elements is returned. Optionally, <code>equivalents()</code> operation can be invoked with several rule names as parameters to return equivalents created by specific rules. The execution of this operation also differs from the 'Execution Scheduling' discussed before, because <code>equivalents()</code> operation invokes both lazy and non-lazy rules.</p> <p>The ordering of the <code>equivalents()</code> operations is sequential and runs in the order of the rules defined. However, this is not the case when a rule is declared <code>@primary</code> in which case the results of that rule will precede all of the other rules.</p> <pre><code>classDiagram\n\nclass Transformation {\n    -source: Object\n    -targets: Object[*]\n}\n\nclass ITransformationStrategy {\n    +transformModels(context : EtlContext)\n}\n\nEolContext &lt;|-- EtlContext\nEtlContext -- TransformationTrace\nEtlContext -- ITransformationStrategy: strategy\nTransformationTrace -- Transformation: transformations *\nTransformation -- TransformRule: rule</code></pre> <p><code>equivalent()</code> operation:</p> <p>The <code>equivalent()</code> operation also has different behaviours when applied to a single source element or a collection. When the operation is applied to a single element only the first element of the result that would have been returned by the <code>equivalents()</code> operation is returned. When applied to a collection, the operation returns a flattened collection. Optionally, <code>equivalent()</code> operation can be invoked with or without parameters.</p> <p>Transformation trace persistance</p> <p>ETL does not provide built-in support for persisting the transformation trace. If you want to access it, you can do so through <code>System.context.transformationTrace</code> and persists parts of the trace in a format of choice e.g. in a <code>post</code> block.</p>"},{"location":"etl.html#etl-override-on-eol-special-assignment-operator","title":"ETL override on EOL Special Assignment Operator","text":"<p>Resolving equivalent(s) or source model elements is quite common in model transformation. However, the ETL syntax for equivalent(s) operations is verbose. So, to improve readability of transformation scripts, ETL overrides the semantics of the EOL <code>SpecialAssignmentStatement</code> (which is <code>::=</code> in concrete syntax) to set the field on the left-hand side to the <code>equivalent</code> of the element on the right-hand side as calculated using the <code>equivalent()</code> operation discussed above. This custom assignment behaviour is meant to simply replace the <code>equivalent()</code> method with <code>::=</code> instead. The snippets below show how its done (don't worry about the terminology, just compare the syntax).</p> <p>Equivalent Operation Snippet: <pre><code>edge.target = t.parent.equivalent();\n</code></pre></p> <p>Special Assignment Operator Snippet: <pre><code>edge.target ::= t.parent;\n</code></pre></p>"},{"location":"etl.html#interactive-transformations","title":"Interactive Transformations","text":"<p>EOL statements can provide interactive capabilities for ETL transformations. In the example below, <code>Tree2Node</code> rule is modified by adding a <code>guard</code> statement that uses EOL's user-input method (<code>UserInput.confirm(String,Boolean)</code>) to ask for user's permission and confirmation of selecting specific Tree elements that need to be transformed to Node elements. The confirmation prompt appears at runtime hence making the model transformation interactive.</p> <pre><code>rule Tree2Node\n    transform t : Tree!Tree\n    to n : Graph!Node {\n\n    guard : UserInput.confirm\n        (\"Transform tree \" + t.label + \"?\", true)\n\n    n.label = t.label;\n    var target : Graph!Node ::= t.parent;\n    if (target.isDefined()) {\n        var edge = new Graph!Edge;\n        edge.source = n;\n        edge.target = target;\n    }\n}\n</code></pre>"},{"location":"etl.html#examples","title":"Examples","text":"<ul> <li> <p>Linked list reversal project reverses a linked list data structure originally stored in XMI format (source model). ETL transformation generates an <code>target.xmi</code> containing the target model. Both source and target metamodels are created using EMF.</p> </li> <li> <p>Flowchart to HTML project is a culmination of small yet expressive transformation scripts that transform elements from a Flowchart model to HTML elements. Important and easily understandable demos on <code>@greedy</code>, <code>@lazy</code>, <code>@primary</code>, <code>equivalent()</code>, one source element to multiple targets, and inheritance concepts have been covered in this ETL project.</p> </li> </ul>"},{"location":"yamtl.html","title":"YAMTL","text":"<p>Yet Another Model Transformation Language (YAMTL) is an expressive model-to-model transformation language that is offered as an internal domain-specific language (DSL) of JVM languages, including Java, Xtend, Groovy and Kotlin.</p> <p>YAMTL is available as an IDE-agnostic Java dependency that augments the Java ecosystem with model analysis and model transformation capabilities that are not yet available in the latest version of Java. YAMTL transformations can be developed, debugged, and analyzed using the preferred Java IDE of choice and they can build upon existing Java dependencies to automate complex tasks. YAMTL operates on models defined with the Eclipse Modeling Framework.</p> <p>YAMTL was found to be the fastest incremental model transformation tool, in general, for dealing with complex transformations between AADL models according to an independent industrial case study1. </p>"},{"location":"yamtl.html#getting-started","title":"Getting Started","text":""},{"location":"yamtl.html#what-you-will-do","title":"What you will do","text":"<p>Create and set up a YAMTL project (without models and metamodels) that is ready for model transformations in an IDE of your choice.</p>"},{"location":"yamtl.html#what-you-need","title":"What you need","text":"<ul> <li>An IDE (e.g. Eclipse, VSCode or IntelliJ)</li> <li>Java 17 or later (Minimum requirement)</li> <li>Gradle 8.0+ (Minimum requirement)</li> <li>Groovy plugin installed in your IDE (see Workspace Configuration to install it)</li> </ul>"},{"location":"yamtl.html#choosing-an-ide","title":"Choosing an IDE","text":"<p>To use YAMTL appropriately, an IDE must be properly configured. Let\"s check out the required configurations for some of the most popular IDEs: Eclipse, IntelliJ, and VSCode.</p>"},{"location":"yamtl.html#eclipse","title":"Eclipse","text":"<p>Open Eclipse IDE and head over to <code>Help \u2192 Eclipse Marketplace</code>. Enter \"Groovy\" and install <code>Groovy Development Tools 5.0.0.RELEASE</code> to be able to run Groovy scripts.</p> <p>Before you run any tasks, make sure your project is using JDK 17 or higher.</p> How to change the Java version in Eclipse<p>To change your JRE, head over to <code>Eclipse \u2192 Preferences \u2192 Java \u2192 Installed JREs \u2192 Choose Java SE 17 or higher</code></p> <p>Now you should be ready to use YAMTL in your modeling projects.</p>"},{"location":"yamtl.html#intellij","title":"IntelliJ","text":"<p>Head over to <code>IntelliJ IDEA \u2192 Preferences \u2192 Plugins</code> and search for <code>Eclipse Groovy Compiler Plugin</code> and install it.</p> <p>Similarly, search for \"gradle\" and install the <code>Gradle</code> plugin from JetBrains. Restart your IDE to apply the changes.</p> <p>Ensure the project is using JDK 17 or higher.</p> How to change the Java version in IntelliJ<p>To change your JDK, head over to <code>IntelliJ IDEA \u2192 Preferences \u2192 Build, Execution, Deployment \u2192 Build Tools \u2192 Gradle</code>. Then, select a <code>Gradle JVM</code> that is JDK 17 or higher.</p> <p>All necessary configurations are now completed!</p>"},{"location":"yamtl.html#vscode","title":"VSCode","text":"<p>First, a groovy support package must be installed. <code>code-groovy</code> extension enables Groovy support for VSCode. In VScode, click on <code>Extensions</code> and search for \"code-groovy\". Install the extension from Marlon Franca.</p> <p>Also, install the <code>Gradle for Java</code> extension published by Microsoft to run the Gradle scripts in a neat interface.</p> <p>Make sure the workspace is using JDK 17 or higher.</p> How to change the Java version in VSCode<p>To change your JRE, head over to <code>Code \u2192 Preferences \u2192 Settings</code> and search for \"JDK\". Check the Gradle <code>Java: Home</code> setting to see if the path points to a location of JDK 17 or higher (update the JDK version if it is any lower).</p> <p></p> <p>The configurations are completed! Get started with YAMTL by installing some dependencies.</p>"},{"location":"yamtl.html#getting-started_1","title":"Getting Started","text":""},{"location":"yamtl.html#what-you-will-do_1","title":"What you will do","text":"<p>Create and set up a YAMTL project (without models and metamodels) that is ready for model transformations in an IDE of your choice.</p>"},{"location":"yamtl.html#what-you-need_1","title":"What you need","text":"<ul> <li>An IDE (e.g. Eclipse, VSCode or IntelliJ)</li> <li>Java 17 or later (Minimum requirement)</li> <li>Gradle 8.0+ (Minimum requirement)</li> <li>Groovy plugin installed in your IDE (see Workspace Configuration to install it)</li> <li>Time to complete: about 10 minutes</li> </ul>"},{"location":"yamtl.html#walkthrough","title":"Walkthrough","text":"<p>First, you need to create a Gradle project in your IDE. Here, are the ways to do so in some common IDEs:</p> <p>Eclipse: Create a new <code>Other</code> project. Then search for <code>Gradle Project</code>, choose a suitable starter project name, and hit <code>Finish</code>.</p> <p>IntelliJ: Go <code>File \u2192 New \u2192 Project... \u2192 New Project</code>. Choose the language as <code>Groovy</code>, build system as <code>Gradle</code>, JDK as 17 or higher, and Gradle DSL as <code>Groovy</code>. </p> <p>VSCode: Do <code>Shift+Cmd+P</code> or <code>Ctrl+Shift+P</code> to open editor commands. Search and click on the <code>Gradle project</code> (may require <code>Gradle for Java</code> extension to be installed). Do <code>Build script DSL as Groovy \u2192 New Project Name</code>. </p> <p>YAMTL uses Gradle as build automation tool and can be executed from Java-SE 17. To add YAMTL to your project you must configure the Gradle build script (<code>build.gradle</code>) of your project. Add the Groovy plugin (at the top of the <code>build.gradle</code> file): <pre><code>plugins {\n    id \"groovy\"\n}\n</code></pre></p> <p>Add the following repositories: <pre><code>repositories {\n    maven{ url 'https://github.com/yamtl/yamtl.github.io/raw/master/mvn-repo/snapshot-repo' }\n    mavenCentral()\n}\n</code></pre></p> <p>Then declare the dependencies (EMF dependencies are optional but since many metamodels use EMF format, it is advised you include it): <pre><code>dependencies {\n    // YAMTL dependencies\n    implementation \"yamtl:yamtl:${yamtlVersion}\"\n\n    implementation \"org.apache.groovy:groovy-all:${groovyAllVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore:${ecoreVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore.xmi:${ecoreXmiVersion}\"\n    implementation \"org.eclipse.emf:org.eclipse.emf.ecore.change:${ecoreChangeVersion}\"\n    implementation \"org.eclipse.xtend:org.eclipse.xtend.core:${xtendVersion}\"\n    implementation \"org.springframework.boot:spring-boot-starter-aop:${springAopVersion}\"\n    implementation \"org.aspectj:org.aspectj:${aspectJVersion}\"\n}\n</code></pre></p> <p>The latest versions of the dependencies are defined in the <code>build.gradle</code> file can be below:</p> <ul> <li>Latest <code>${yamtlVersion}</code> can be found at yamtl.github.io (release notes).</li> <li>Find the latest <code>${groovyAllVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreXmiVersion}</code> on Maven Central</li> <li>Find the latest <code>${ecoreChangeVersion}</code> on Maven Central</li> <li>Find the latest <code>${xtendVersion}</code> on Maven Central</li> <li>Find the latest <code>${springAopVersion}</code> on Maven Central</li> <li>Find the latest <code>${aspectJVersion}</code> on Maven Central</li> </ul> <p>Finally, build the project to install the dependencies. </p> <p>You are now ready to use your YAMTL project! Let's now learn how to create a model transformation definition.</p> <ul> <li>First, create a transformation script in <code>src/main/groovy</code> folder (you could also add a package to use multiple scripts) with the  <code>.groovy</code> suffix. Then, import a few YAMTL and EMF libraries:</li> </ul> <pre><code>import static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n</code></pre> <ul> <li>Create a specialization of the <code>YAMTLModule</code> by extending it:</li> </ul> <pre><code>class FirstExample extends YAMTLModule \n</code></pre> <ul> <li>Define a new public method <code>FirstExample</code> and pass the source and target metamodels of <code>EPackage</code> type as parameters (Ecore metamodel files are accessed through <code>EPackage</code>). Note: Depending on your case, you may have the same source and target metamodels so you can just pass one parameter.</li> </ul> <pre><code>public FirstExample(EPackage sourcePk, EPackage targetPk)\n</code></pre> <p>OR, if both source and target metamodels are the same:</p> <pre><code>public FirstExample(EPackage llPk)\n</code></pre> <ul> <li>To enable EMF functionality to the YAMTL module, initialize an EMF extension:</li> </ul> <pre><code>YAMTLGroovyExtensions_dynamicEMF.init(this)\n</code></pre> <ul> <li>Within the constructor, a <code>header()</code> is required to define the signature of the transformation: declaration of input and output models. <code>.in()</code> clause defines the characteristics of the input model, where the first parameter is the model's name in quotation marks <code>\"\"</code> and the second parameter is the metamodel to which the input model conforms. The same applies to the output model definition within the <code>.out()</code> clause. </li> </ul> <pre><code>header().in(\"in\", sourcePk).out(\"out\", targetPk)\n</code></pre> <ul> <li>Next is the <code>ruleStore()</code> which contains a list of rule(s). Each rule has one or more input elements which are transformed to one or more output elements. The concrete syntax for rules is described in the next section.</li> </ul> <pre><code>ruleStore([\n    rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes)\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n])\n</code></pre> <ul> <li>You can also add optional helpers that can perform computations of values during the initialization of the transformation. Helpers are contained as a list within the <code>helperStore()</code> operation.</li> </ul> <pre><code>helperStore([\n    //Helpers\n])\n</code></pre> <p>That is how you can create a YAMTL transformation script. For a better idea of a working MT definition check out this Groovy script for an example project:</p> <pre><code>import static yamtl.dsl.Rule.*\nimport org.eclipse.emf.ecore.EPackage\nimport yamtl.core.YAMTLModule\nimport yamtl.groovy.YAMTLGroovyExtensions_dynamicEMF\n\nclass FirstExample extends YAMTLModule {\n\n    //In this case, both source and target metamodels are same\n    public FirstExample(EPackage llPk) {\n\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n\n        header().in('in', llPk).out('out', llPk)\n\n        ruleStore([\n            rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes)\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n        ])\n    }\n}\n</code></pre> <p>That's all! Now you know how to create your own YAMTL project and define a model transformation script. To learn how to use rules, see Concrete Syntax section. Or if you want to learn how to run YAMTL projects and configure models, head over to Examples so you can understand model transformations and special YAMTL operations of varying difficulties.</p>"},{"location":"yamtl.html#basic-syntax","title":"Basic Syntax","text":"<p>A YAMTL model transformation is defined as a class that specializes the <code>YAMTLModule</code> class, which provides access to the YAMTL DSL and to methods to configure and execute model transformations:</p> GroovyXtendJavaKotlin <pre><code>class &lt;name&gt; extends YAMTLModule {\npublic &lt;name&gt; (EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\nYAMTLGroovyExtensions_dynamicEMF.init(this)\nheader().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\nruleStore([ /* rules here */ ])\nhelperStore([  /* managed helpers here */ ])\n}\n}\n</code></pre> <pre><code>class &lt;name&gt; extends YAMTLModule {\nnew(EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\nheader().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\nruleStore(#[ /* rules here */ ])\nhelperStore(#[ /* managed helpers here */ ])\n}\n}\n</code></pre> <pre><code>public class &lt;name&gt; extends YAMTLModule {\npublic &lt;name&gt;(EPackage &lt;pk1&gt;, EPackage &lt;pk2&gt;) {\nheader().in(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;);\nruleStore(List.of( /* rules here */ ));\nhelperStore(List.of( /* managed helpers here */ ));\n}\n}\n</code></pre> <pre><code>class &lt;name&gt;(&lt;pk1&gt;: EPackage, &lt;pk2&gt;: EPackage) : YAMTLModule() {\ninit {\nheader().`in`(&lt;in_domain_name1&gt;,&lt;pk1&gt;).out(&lt;in_domain_name2&gt;,&lt;pk2&gt;)\nruleStore(listOf( /* rules here */ ))\nhelperStore(listOf( /* managed helpers here */ ))\n}\n}\n</code></pre> <p>In the code above there are four important sections:</p> <ul> <li>Constructor signature: It should include the different metamodels (<code>EPackage</code> instances) used in the transformation. </li> <li>Header: This section declares the signature of the model transformation using a unique name for each domain and its corresponding metamodel, which can be shared across domains.  </li> <li>Rule Store: This section declares a list of transformation rules.</li> <li>Helper Store (Optional): Accepts a list of managed helpers. Managed helpers are attributes or methods that are optimized in YAMTL using an internal cache for their results. Unmanaged helpers are declared as standard methods of the module class. This section is optional if no managed helpers are needed.</li> </ul> <p>The basic format of a YAMTL rule definition is as follows:</p> <pre><code>rule(\"&lt;name&gt;\")\n    .in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)\n        [.derivedWith(&lt;QUERY&gt;)]?\n        [.filter(&lt;FILTER&gt;)]?\n    .out(\"&lt;out_object_name&gt;\", &lt;out_object_type&gt;, &lt;ACTION&gt;)\n</code></pre> <p>Legend</p> <p><code>&lt;&gt;</code> indicates user-definable expressions. Note that these are placeholders and not part of the actual YAMTL syntax. Lowercase snake case (e.g., <code>in_object_name</code>) usually denotes variable names and types, including lists of variable names. Uppercase snake case (e.g., <code>&lt;FILTER&gt;</code> or <code>&lt;ACTION&gt;</code>) represents lambda expressions, and they are written using the syntax of the host language. <code>[]?</code> means optional.</p> <p>A rule is declared using <code>rule(\"&lt;name&gt;\")</code> with a rule name. The static operation <code>rule</code> can be used with <code>import static yamtl.dsl.Rule.*</code>. Each rule consists of one or more input element(s), defined using <code>in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)</code> operation that requires a source element name and type; an optional <code>.derivedWith(&lt;QUERY&gt;)</code> clause where <code>&lt;QUERY&gt;</code> is a lambda expression of type <code>Supplier&lt;EObject&gt;</code> that produces the object that will be matched to the input element; an optional filter condition expressed with <code>filter(&lt;FILTER&gt;)</code> where <code>&lt;FILTER&gt;</code> is a lambda expression of type <code>Supplier&lt;Boolean&gt;</code>; and one or more output element(s), declared with <code>out(\"out_object_name\", &lt;out_object_type&gt;, &lt;ACTION&gt;)</code> requiring a target element name and type, along with a side-effecting lambda expression <code>&lt;ACTION&gt;</code> of type <code>Runnable</code> containing action statements that initialize or update the output object attributes and references. </p>"},{"location":"yamtl.html#yamtl-semantics","title":"YAMTL Semantics","text":"<p>Model transformations can be used to define model queries by using pattern matching, out-place model transformation by mapping an input model into a new output model, or in-place model transformations by rewriting a given model.</p>"},{"location":"yamtl.html#pattern-matching-semantics","title":"Pattern Matching Semantics","text":"<p>Pattern matching is the process by which YAMTL tries to find object graphs in the input model where the input pattern of a rule can be matched. </p> <p>There are two main types of input elements: matched elements, which are mapped by YAMTL to objects in the input model, and derived elements, which are defined with a <code>.derivedWith(&lt;QUERY&gt;)</code> clause and need to be derived from input elements that have been matched in preceding input elements. </p> <p>To find a match for a rule, YAMTL first maps each matched input element of the rule to objects in the input model in the order in which they appear. For derived elements, YAMTL tries to complete the total match by processing query expressions in the order that they were declared. If a query cannot be resolved to an object, that rule's match is invalid. </p> <p>A match for a matched rule must be unique. That is, no other rule should be applicable to the same match. Uniqueness of matches is checked at runtime using the flag <code>YAMTLModule::setEnableCorrectnessCheck(Boolean)</code>, which is <code>true</code> by default. Non-unique matches are allowed when using lazy rules, which are called on demand, and when using ToMany rules, which create a fixed number of rule application for the same match.</p> <p>A match is complete when all input elements are mapped to objects, either implicitly via matched input elements or explicitly via derived input elements. A match is defined as a map where the key is the input variable name and the value is the corresponding matched <code>EObject</code>.</p> <p>Model-sensitive pattern matching</p> <p>The input elements are ordered by the size of their type extent (smaller-sized types are matched before bigger ones) when enabling the flag <code>YAMTLModule::setEnabledMatchingInputElementOrderBySize(true)</code>. This can lead to significant run-time improvements when the distribution of objects across types is imbalanced.</p> <p>This optimization can, however, cause problems when the order of the input elements alters the order in which input element declaration is expected in filter expressions. For example, assuming that <code>Type1</code> declares a boolean method <code>isEnabled()</code> and that <code>Type2</code> has fewer objects than <code>Type1</code>, the order of input elements in the following input pattern</p> <pre><code>.in(\"a\", Type1)\n.in(\"b\", Type2).filter{ a.isEnabled() }\n</code></pre> <p>will be changed by the flag <code>setEnabledMatchingInputElementOrderBySize</code>. This will cause a problem because the input element <code>b</code> will be evaluated first and its filter condition needs \"a\" to be matched first. In such cases, the flag <code>YAMTLModule::setEnabledMatchingInputElementOrderBySize</code> must be kept disabled.</p> <p>A match for a rule is valid when it is unique, complete and all of the filters of the input pattern are satisfied. Filters come in two flavours:</p> <ul> <li>Local filters: defined for an input element <code>.in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;).filter(&lt;FILTER&gt;)</code>. The lambda expression <code>&lt;FILTER&gt;</code> can use any object variable declared in a preceding input element.</li> <li>Global filters: defined for the last input element of the input pattern. All input object variables can be used for defining the filter expression. A single global filter can be defined for a rule using the clause <code>.globalFilter(&lt;FILTER&gt;)</code> at the end of the input pattern. </li> </ul> <p>Design principles for efficient pattern matching</p> <ol> <li> <p>Matched input elements should only be defined for matching objects that are not related to each other through references. If they are then they should be defined as derived elements instead.</p> </li> <li> <p>Local element filter conditions should be opted for instead of global rule filter conditions to help the matching algorithm remove invalid matches as soon as possible (reduces execution time).</p> </li> <li> <p>Once it is known that only unique matches are found within a model for a given set of rules, the model transformation containing them can be executed more efficiently by disabling the uniqueness correctness check with <code>YAMTLModule::setEnableCorrectnessCheck(false)</code>.</p> </li> </ol> <p>YAMTL's pattern matcher can be used to implement model queries. A model query is a rule that only has an input pattern and that may have a final action block <code>endWith(&lt;ACTION&gt;)</code>:</p> <pre><code>rule(\"&lt;name&gt;\")\n    .in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)[.derivedWith(&lt;QUERY&gt;)]?[.filter(&lt;FILTER&gt;)]?\n    .query()\n    [.endWith(&lt;ACTION&gt;)]?\n</code></pre> <p>The <code>&lt;ACTION&gt;</code> in <code>endWith(&lt;ACTION&gt;)</code> is a lambda expression of type <code>Runnable</code> that may use the input element variables to perform some action on the input objects that have been matched, e.g., reporting error messages or computing metrics.</p> <p>To configure and execute a YAMTL module for implementing rule-based queries, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = BaseQuery.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef query = new BaseQuery(resource.contents[0])\nYAMTLGroovyExtensions.init(query)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nquery.execute()\n</code></pre> <pre><code>val resource = BaseQuery.loadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval query = new BaseQuery(resource.contents[0] as EPackage)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nquery.execute()\n</code></pre> <pre><code>Resource resource = (Resource) BaseQuery.loadMetamodel(\"&lt;path_to_metamodel&gt;\");\nBaseQuery query = new BaseQuery((EPackage) resource.getContents().get(0));\nquery.setSelectedExecutionPhases(ExecutionPhase.MATCH_ONLY);\nquery.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nquery.execute();\n</code></pre> <pre><code>val resource = BaseQuery.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval query = BaseQuery(resource.contents[0])\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nquery.execute()\n</code></pre> <p>When using dynamic EMF for accessing metamodel metadata (i.e., EMF code has not been generated for the metamodel), use the static method <code>YAMTLModule::loadMetamodel(\"&lt;path_to_metamodel&gt;\")</code>, which works with both Ecore files (<code>.ecore</code>) and with EMFatic files (<code>.emf</code>) to load the metamodel. Then instantiate the YAMTL module containing the model query, configure it to execute only the matching phase, load the input models and, finally, execute the query using the method <code>YAMTLModule::execute()</code>. </p> <p>The results of the queries can be handled in blocks <code>endWith(&lt;ACTION)</code> of query rules, for example printing them in the output console or accumulating them in local variables.</p>"},{"location":"yamtl.html#out-place-transformation-semantics","title":"Out-place Transformation Semantics","text":"<p>YAMTL modules are typically used to specify model-to-model transformations, where the objects of an input model are mapped to objects of an output model that is created from scratch. This is commonly referred to as out-place transformation because the input model is read-only and not modified.</p> <p>This semantics is characterized by the following properties:</p> <ul> <li>Immutability of Source Models: The input model remains immutable during the transformation process. Consequently, a new output model is generated to encapsulate the transformation result, thereby preserving the integrity of the original input model. This immutability eliminates the risk of unintended side effects that could potentially alter the source model in undesirable ways.</li> <li>Separation of Concerns: Out-of-place transformations naturally enable a clear separation of concerns between the input and output models. This is beneficial for modularisation and reusability of transformation rules, as each rule can be designed to perform a specific, self-contained task without affecting the input model.</li> <li>Traceability and Versioning: The creation of a separate output model in out-of-place transformations provides better support for traceability and versioning. Each transformation produces a new model that can be stored, compared, and traced back to its originating source model. This facilitates debugging, testing, and long-term maintenance. This feature also enables the incremental execution of model transformations based on change propagation from the input model to the output model.</li> </ul> <p>Side effects in a model transformation are specified in the <code>out</code> elements of rules. For each transformation rule that has been matched, the rule is applied by creating an object in the output model for each <code>out</code> element and the object is initialized using the corresponding <code>&lt;ACTION&gt;</code> expression. Within a rule, an <code>ACTION</code> expression can refer to:</p> <ul> <li>the input object variables (either matched or derived) of that rule, </li> <li><code>using</code> variables of that rule, and </li> <li>all output object variables of that rule.</li> </ul> <p>To configure and execute a YAMTL module for implementing an out-place transformation, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef xform = new XForm(resource.contents[0])\nYAMTLGroovyExtensions.init(xform)\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nxform.execute()\nxform.saveOutputModels([\"&lt;out_domain_name\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>val resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval xform = new XForm(resource.contents[0] as EPackage)\nxform.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nxform.execute()\nxform.saveOutputModels(#[ \"&lt;out_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\n</code></pre> <pre><code>Resource resource = (Resource) YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\");\nXForm xform = new XForm((EPackage)resource.getContents().get(0));\nxform.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nxform.execute();\nxform.saveOutputModels(Collections.singletonMap(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>val resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval xform = XForm(resource.contents[0])\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nxform.execute()\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>When an expression needs to reference output objects that are initialized by other rules, the operation <code>YAMTLModule::fetch()</code> needs to be used. The primary purpose of the <code>fetch</code> operation is to retrieve output objects corresponding to a given input object through the application of a transformation rule. The simplest version is suitable for matched rules that have a single object pattern in both the input and output patterns: <code>fetch(input_matched_object)</code> will return the output object created by the rule that matched <code>input_matched_object</code>.</p> <p>Using Actions Effectively</p> <p>In a rule with an output element <code>.out(&lt;out_object_name&gt;, &lt;out_object_type&gt;, &lt;ACTION&gt;)</code>, the expression <code>&lt;ACTION&gt;</code> should only be used to initialize the output object of type <code>&lt;out_object_type&gt;</code> that is created by this output element.</p> <p>Creation of Objects</p> <p>YAMTL augments mainstream JVM programming languages with declarative model transformation capabilities, yet imperative features of the host languages can still be used. Declarative object creation is normally handled in <code>out</code> elements in the output pattern of a rule, when an output element is defined with a new name it creates a new instance of the initialized object. </p> <p>Using imperative features, ad-hoc objects that are manually created using an object factory and assigned to an output element in the <code>ACTION</code> expression, are not traced by YAMTL. This means such non-traced objects cannot be fetched from another rule using the operation <code>fetch()</code>.</p>"},{"location":"yamtl.html#in-place-semantics","title":"In-place Semantics","text":"<p>This semantics is experimental.</p> <p>An in-place transformation in YAMTL is a model transformation where the model is modified directly to produce the desired output model, without creating a new or separate model as the output. In other words, the transformation process occurs within the same model instance, and the original model is incrementally updated to match the structure and content specified by the transformation rules.</p> <p>This approach has several implications and characteristics:</p> <ul> <li>Mutability of Source Models: In in-place transformations, the input model is mutable, meaning that its elements can be modified during the transformation process. This is in contrast to out-of-place transformations, where a new model is created as the output, leaving the input model unchanged.</li> <li>Efficiency: In-place transformations can be more efficient in terms of memory usage and execution time compared to out-of-place transformations, especially when dealing with large models. This efficiency is due to the avoidance of duplicating the entire input model structure in the output model. </li> <li>Potential Side Effects: Since the input model is modified directly, it is essential to carefully manage and control potential side effects. Changes made during the transformation might affect the application of transformation rules or introduce inconsistencies if not handled correctly.</li> </ul> <p>When declaring an in-place transformation, the header of the module containing the in-place transformation rules must identify the parameter that refers to the model to be modified in-place using the keyword <code>inOut</code>: <code>header().inOut(&lt;inOut_domain_name&gt;,&lt;pk&gt;)</code>.</p> <p>YAMTL in-place transformations can be both additive and subtractive:</p> <ul> <li>To create new objects, use <code>out</code> elements in rule output patterns that do not correspond to an <code>in</code> domain, or any of its parent rules.</li> <li>To update existing objects, use <code>out</code> elements in rule output patterns that do correspond to an <code>in</code> domain of the same rule, or any of its parent rules.</li> <li>To delete objects that exist in the model, use <code>.drop()</code> on the corresponding <code>out</code> element that refers to an <code>in</code> element. The <code>in</code> element must be matched by the rule in order for it to be deleted. When using <code>.drop()</code> the following flag must be disabled for the module <code>xform.enableUpdateExtent(false)</code>, where <code>xform</code> refers to the YAMTLModule instance that declares the model transformation rules. <code>drop()</code> has delete cascade semantics that indicates both the object and its contents following containment references are removed. When an object is deleted from the model, all the objects contained through containment references in it will also be removed.</li> <li>YAMTL also offers a less dramatic option to avoid deleting objects from the model by freezing parts of the model. An object in the model is said to be frozen when YAMTL's pattern matcher is oblivious to it.  Objects can be frozen/unfrozen using the operations <code>.freeze()</code>/<code>.unfreeze()</code> on <code>inOut</code> elements, i.e. to those <code>out</code> elements whose name and type coincides with an <code>in</code> element. When using  <code>.freeze()</code>/<code>.unfreeze()</code> the following flag must be disabled for the module <code>xform.enableUpdateExtent(false)</code>, where <code>xform</code> refers to the YAMTLModule instance that declares the model transformation rules. </li> </ul> <p>Since rules are applied over a model in-place, the side-effect of a rule application may enable additional rules and the pattern matching process needs to be performed iteratively. YAMTL provides two strategies to evaluate rules:</p> <ul> <li>Single-Match Mode: As soon as the pattern matcher finds a match, the associated rule is executed. This mode is enabled with the flag <code>xform.setWithStagedExecution(false)</code>, where <code>xform</code> is the <code>YAMTLModule</code> instance containing the declaration of transformation rules. In case of non-terminating transformations, the number of transformation steps can be limited by setting a cap using <code>YAMTLModule::setTransitionUpperBound(Long)</code>, which by default is set to <code>Long.MAX_VALUE</code>.</li> <li>Staged Mode: Rules are evaluated in stages, where each stage involves identifying all applicable matches prior to rule execution. This evaluation mode is similar to the evaluation strategy used in out-place transformations. The difference is that the transformation may consist of different stages. This mode is enabled with the flag <code>xform.setWithStagedExecution(true)</code>, where <code>xform</code> is the <code>YAMTLModule</code> instance containing the declaration of transformation rules. The number of stages that are perfomed can also be capped using <code>YAMTLModule::setStageUpperBound(Long)</code>, which by default is set to <code>1</code>.</li> </ul> <p>To configure and execute a YAMTL module for implementing an in-place transformation, use the following template:</p> GroovyXtendJavaKotlin <pre><code>def resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\ndef xform = new XForm(resource.contents[0])\nYAMTLGroovyExtensions.init(xform)\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\nxform.execute()\nxform.saveOutputModels([\"&lt;out_domain_name\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>val resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\") as Resource\nval xform = new XForm(resource.contents[0] as EPackage)\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\nxform.loadInputModels(#[ \"&lt;in_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\nxform.execute()\nxform.saveOutputModels(#[ \"&lt;out_domain_name&gt;\" -&gt; \"&lt;path_to_model&gt;\" ])\n</code></pre> <pre><code>Resource resource = (Resource) YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\");\nXForm xform = new XForm((EPackage)resource.getContents().get(0));\nxform.setInplace(true); // enables the in-place transformation semantics\nxform.setWithStagedExecution(false); // YAMTL to use one match at a time\nxform.enableUpdateExtent(false); // to be used with drop() and freeze()/unfreeze()\nxform.loadInputModels(Collections.singletonMap(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\nxform.execute();\nxform.saveOutputModels(Collections.singletonMap(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>val resource = YAMTLModule.loadMetamodel(\"&lt;path_to_metamodel&gt;\")\nval xform = XForm(resource.contents[0])\nxform.setInplace(true) // enables the in-place transformation semantics\nxform.setWithStagedExecution(false) // YAMTL to use one match at a time\nxform.enableUpdateExtent(false) // to be used with drop() and freeze()/unfreeze()\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\nxform.execute()\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>In-place semantics and fetch()</p> <p>The mapping from input match to output match is traced as a transformation step in the out-place semantics only. In the in-place semantics, transformation steps are not traced and the <code>fetch()</code> operation cannot be used to resolve references to output objects from input objects (or the matches that contain them). The reason is that the transformation executes modifications on the input model, and references to objects in that model are reachable and need not be resolved using <code>fetch()</code>.</p>"},{"location":"yamtl.html#yamtl-rules","title":"YAMTL Rules","text":"<p>YAMTL is as expressive as ATL so it also has a lot of optional operations. These options provide a more thorough (full) syntax for the language.</p> <pre><code>rule(\"&lt;name&gt;\")\n    [.inheritsFrom(&lt;ruleNameList&gt;)]? \n    [.isAbstract()]? \n    [.isLazy() | .isUniqueLazy()]? \n    [.isTransient()]?\n    {\n        .in(\"&lt;in_object_name&gt;\", &lt;in_object_type&gt;)\n        [(.filter(&lt;FILTER&gt;) | .derivedWith(&lt;QUERY&gt;))]?\n    }+\n    [.using(\"&lt;var_name&gt;\", &lt;QUERY&gt;)]*\n    [.globalFilter(&lt;FILTER&gt;)]?\n    {\n        .out(\"&lt;out_object_name&gt;\", &lt;out_object_type&gt;, &lt;ACTION&gt;)\n        [.overriding()]?\n        [.drop()|.freeze()|.unfreeze()]?\n    }+\n    [.endWith(&lt;ACTION&gt;)]?\n    [.priority(P)]?\n</code></pre> <p>Legend</p> <p><code>&lt;&gt;</code> indicates user-definable expressions, <code>[]?</code> means optional, <code>[]*</code> means operation can occur 0 or more times, <code>{}+</code> means operation can occur 1 or more times. These symbols are not part of the actual YAMTL syntax.</p> <p>YAMTL has two types of input elements: matched and derived. Matched elements are initialized using YAMTL's matching algorithm, whereas derived elements are initialized using a contextual query and are dependent on at least one matched element. Intuitively, each rule has at least one matched input element as you would expect.</p> <p>Every rule has several options for additional customization. They will be discussed from top to bottom of the full syntax provided above:</p> <ul> <li>The <code>inheritsFrom(&lt;ruleNameList&gt;)</code> operation is declared when the current rule inherits from parent rule(s) where <code>ruleNameList</code> is a comma-separated list of strings and the order of inheritance is specified sequentially. An optional <code>abstract</code> tag is used for abstract rules which cannot be matched automatically or applied. </li> <li>Lazy rules can be declared with <code>isLazy()</code> or <code>isUniqueLazy()</code>. These rules are only applicable when the matched input elements are explicitly provided using an expression involving the operation <code>fetch</code>. </li> <li>A rule defined as <code>isTransient()</code> does not persist the target (output) elements when the target model flushes to physical storage.</li> </ul> <p>The input pattern in a rule determines where the rule should be applied and it consists of at least one input element, which can be configured with the following options: * A <code>filter(&lt;FILTER&gt;)</code> clause enables the user to add a local filter condition that needs to be satisfied by the matched object of the corresponding input element.  * A <code>derivedWith(&lt;QUERY&gt;)</code> clause is used to declare an input element as derived where <code>QUERY</code> is a lambda expression of the \"EObject\" type used to calculate the value of the match. </p> <p>Rules can be equipped with local variables that can be initialized with using the matched variables. Such local variables are helpful for holding primitive values obtained from the matched objects. These are declared with the block <code>.using(\"&lt;var_name&gt;\", &lt;QUERY&gt;)</code>, where <code>&lt;var_name&gt;</code> is the name of the variable, and <code>&lt;QUERY&gt;</code> is an expression of type <code>Supplier&lt;Object&gt;</code>, which should return the variable value. Local variables can then be used in global filters and actions, both in <code>out</code> elements and in the block <code>endWith</code>.</p> <p>A global filter condition for a rule can be added after the input element block using <code>globalFilter(&lt;FILTER&gt;)</code> clause which allows the user to add filter(s) applicable to the global scope of the rule.</p> <p>The output pattern of a rule defines the side effects of the rule and consists of at least one output element, which can be configured with the following options: * An <code>overriding()</code> qualifier is used to override inherited action expression(s) in the output element of a descendant rule, as discussed in rule inheritance. * Elements that are used both as input and output can be managed using the options <code>.drop()</code> or <code>.freeze()/.unfreeze()</code>, as explained in the Subsection In-place Semantics.</p> <p>Rules can also have the option <code>endWith(&lt;ACTION&gt;)</code> to define an optional <code>&lt;ACTION&gt;</code>, of type <code>Runnable</code>, that can refer to any of the rule's elements and any local variables. Note that the <code>endWith()</code> method is purely for convenience: it enables performing actions at the end of the rule execution for each particular match. </p> <p>To change the priority of a rule, you can use the <code>priority(P)</code> operation where P is a \"long\" value. Rules with lower priority are applied first by the YAMTL matching algorithm. Additionally, YAMTL provides attribute helpers for computing values during the initialization of the model transformation. </p> <p>The helpers are defined in  the block <code>helperStore()</code> of the the transformation's constructor. The helper syntax <code>Helper(\"&lt;helperName&gt;\")</code> is used to define an attribute helper with the name in single quotes and is followed by a query lambda expression enclosed in square brackets. </p>"},{"location":"yamtl.html#fetch","title":"<code>fetch()</code>","text":"<p>The fetch operation in YAMTL, <code>YAMTLModule::fetch()</code>, is used to retrieve output objects that correspond to given input objects through the application of transformation rules. The main purpose of <code>fetch()</code> is to resolve references to output objects that are created by other rules. Since rules in YAMTL transformations execute independently, they cannot directly access the output objects produced by other rules. The fetch operation serves as a bridge to connect these separate rule contexts.</p> <p>When a rule's action needs to reference an output element initialized by another rule, it uses fetch with the input object to look up the corresponding output object. For example, <code>fetch(input_object)</code> returns the output object created by the rule that matched <code>input_object</code>.</p>"},{"location":"yamtl.html#multiple-elements-in-the-input-pattern","title":"Multiple elements in the Input Pattern","text":"<p>When the input pattern contains more than one element, instead of using one single input object, a valid match must be provided by using a map where the keys are <code>&lt;in_object_name&gt;</code>s and the values are the matched <code>EObject</code>s.</p>"},{"location":"yamtl.html#multiple-elements-in-the-output-pattern","title":"Multiple Elements in the Output Pattern","text":"<p>When the output pattern comprises several object patterns, it's necessary to specify which output element we wish to fetch: <code>fetch(&lt;input_matched_object&gt;, \"&lt;out_var_name&gt;\")</code> will return the output object linked to the output element <code>outVarName</code>. If a matched rule with a complex output pattern also uses the <code>toMany</code> declaration, the output object can be retrieved with <code>fetch(&lt;input_matched_object&gt;, \"&lt;out_var_name&gt;\", &lt;i&gt;)</code>.</p>"},{"location":"yamtl.html#calling-lazy-rules","title":"Calling Lazy Rules","text":"<p>The fetch operation is the only mechanism available to execute lazy rules, as explained in the subsection Lazy Rules.</p>"},{"location":"yamtl.html#helpers","title":"Helpers","text":"<p>In JVM languages, other than Groovy, the fetch operation is also used to call helpers, as explained in the subsection Helpers.</p>"},{"location":"yamtl.html#handling-tomany-rules","title":"Handling ToMany Rules","text":"<p>ToMany rules can be applied to the same input object multiple times. In such cases, we can retrieve the output objects obtained in each rule application using the operation fetch(), as explained in the subsection ToMany Rules.</p>"},{"location":"yamtl.html#variables-in-execution-context","title":"Variables in Execution Context","text":"<p>In JVM languages, other than Groovy, the fetch operation is also used to call helpers, fetch variables from the execution environment, with the expression <code>fetch(\"&lt;variable-name&gt;\")</code>.</p>"},{"location":"yamtl.html#allinstanceseclass","title":"<code>allInstances(EClass)</code>","text":"<p>The <code>allInstances(&lt;typeName&gt;)</code> operation is used to create OCL-like queries in lambda expressions and can be invoked in any of the following expressions: <code>&lt;FILTER&gt;</code>, <code>&lt;QUERY&gt;</code> and <code>&lt;ACTION&gt;</code>.</p>"},{"location":"yamtl.html#lazy-rules","title":"Lazy Rules","text":"<p>Lazy rules, similar to matched rules, transform input objects into output objects. However, unlike matched rules that apply automatically, lazy rules must be explicitly invoked. This can be achieved using the fetch() operation. Since they only execute when called, they produce outputs based on specific inputs without unnecessary runs. This ensures that transformations only occur when required, enhancing both modularisation and efficiency.</p> <p>There are two types of lazy rules:</p> <ul> <li>Standard Lazy Rules (<code>isLazy()</code>): These are the basic form of lazy rules. Once called, they take specified input elements from the input model and produce corresponding output elements in the output model. However, if invoked multiple times with the same inputs, they may produce redundant output elements. A typical use case that illustrates the use of rules <code>isLazy()</code> is for maintaining a trace or log of all transformation steps, as redundant objects can act as a record of every individual transformation invocation, even if they are from the same input.</li> <li>Unique Lazy Rules (<code>isUniqueLazy()</code>): These are an enhanced version of the standard lazy rules. The primary distinction is their guarantee of execution uniqueness. If a unique lazy rule is called more than once with the same input elements, it ensures that the transformation occurs only once. This means that the result of the initial call is cached and reused for subsequent calls with identical inputs, preventing the generation of duplicate output elements. Unique lazy rules repurpose the declarative semantics of matched rules with a lazy evaluation strategy.</li> </ul> <p>A lazy rule, whether unique or non-unique, requires explicit invocation to produce an output element. This is executed by using the rule name using the fetch operation as follows:</p> <ul> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;)</code> for lazy rules with a single input object and multiple output objects.</li> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;, &lt;i&gt;)</code> for <code>toMany</code> lazy rules with a single input object and multiple output objects.</li> <li><code>fetch(&lt;input_matched_object&gt;, &lt;out_object_name&gt;, &lt;rule_name&gt;, &lt;argsMap&gt;)</code> for lazy rules with a single input object and multiple output objects that, in addition, are parameterized. <code>&lt;argsMap&gt;</code> is a map of type <code>Map&lt;String,Object&gt;</code>, where the keys are parameter names and the values are the actual parameter values.</li> </ul>"},{"location":"yamtl.html#helpers_1","title":"Helpers","text":"<p>A helper in YAMTL streamlines the writing of transformation rules by offering reusable expressions. Think of it as creating utility functions or methods in conventional programming languages.</p> <p>In YAMTL, you can define helpers using standard constructs from the host programming language:</p> <ul> <li>Attributes with initialization expressions.</li> <li>Static operations that apply at the class level across all instances.</li> <li>Operations specific to objects.</li> </ul> <p>YAMTL further boosts these helpers' utility by caching their computations, optimizing runtime performance. Below, we present how to declare these helpers and call them in your transformations.</p>"},{"location":"yamtl.html#attribute-helpers","title":"Attribute Helpers","text":"<p>The method <code>staticAttribute(\"&lt;name&gt;\", &lt;BODY&gt;)</code> creates an attribute <code>&lt;name&gt;</code>. Its value gets determined by the <code>&lt;BODY&gt;</code> expression, which must be of type <code>Supplier&lt;Object&gt;</code>.</p> <p>Attribute helpers shine when used with the <code>allInstances(&lt;EClass&gt;)</code> operation. This operation fetches a list containing all instances of the type <code>&lt;EClass&gt;</code> present in the input model. The expression <code>&lt;BODY&gt;</code> must return the value used to initialize the attribute, which can be an <code>EObject</code> or a primitive value.</p> GroovyXtendJavaKotlin <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", {  // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n})\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", [|  // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n])\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\", new Supplier&lt;Object&gt;() {  @Override\npublic Object get() {\n// an expression returning a value from allInstances(&lt;InputEClass&gt;)\n}\n});\n</code></pre> <pre><code>staticAttribute(\"&lt;AttributeName&gt;\") {  // an expression returning a value from allInstances(&lt;InputEClass&gt;)\n}\n</code></pre> <p>An attribute helper can then be called by name. While the YAMTL Groovy DSL allows us to consider the attribute helper as a variable using its name (without the String quotes) directly, the operation <code>fetch</code> needs to be used in all other programming languages:</p> GroovyXtendJavaKotlin <pre><code>&lt;AttributeName&gt;\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre> <pre><code>fetch(\"&lt;AttributeName&gt;\")\n</code></pre>"},{"location":"yamtl.html#static-operation","title":"Static Operation","text":"<p>To manage static methods, YAMTL uses <code>staticOperation(\"&lt;name&gt;\", &lt;FUNCTION&gt;)</code> to define an operation <code>&lt;name&gt;</code> where <code>&lt;FUNCTION&gt;</code> is a lambda expression with a list of parameters specified as a map. The keys in the map are the names of the parameters, and the values are the actual arguments. Within the body of the lambda expression, you can access the arguments map using <code>argMap</code> and must ensure to return a value.</p> GroovyXtendJavaKotlin <pre><code>staticOperation(\"&lt;OperationName&gt;\", { argMap -&gt; // returns the value of the parameter with name &lt;param_name&gt;\nargMap.&lt;param_name&gt; })\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\", [ argMap | // returns the value of the parameter with name &lt;param_name&gt;\nargMap.get(\"&lt;param_name&gt;\")\n])\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\", argMap -&gt; {\n// returns the value of the parameter with name &lt;param_name&gt;\nreturn argMap.get(\"&lt;param_name&gt;\");\n});\n</code></pre> <pre><code>staticOperation(\"&lt;OperationName&gt;\") { argMap -&gt;\n// returns the value of the parameter with name &lt;param_name&gt;\nargMap[\"&lt;param_name&gt;\"]\n}\n</code></pre> <p>Static operations are invoked by their names and the list of arguments, specifying the name of the parameter and the actual argument value. While the YAMTL Groovy DSL allows calling the static operation directly, all other programming languages require the <code>fetch</code> operation:</p> GroovyXtendJavaKotlin <pre><code>&lt;OperationName&gt;([\"&lt;param1&gt;\" : &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", #[\"&lt;param1&gt;\" -&gt; &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", Map.of(\"&lt;param1&gt;\", &lt;value1&gt;, ...));\n</code></pre> <pre><code>fetch(\"&lt;OperationName&gt;\", mapOf(\"&lt;param1&gt;\" to &lt;value1&gt;, ...))\n</code></pre>"},{"location":"yamtl.html#contextual-operation","title":"Contextual Operation","text":"<p>To manage class methods, YAMTL uses <code>contextualOperation(\"&lt;name&gt;\", &lt;BIFUNCTION&gt;)</code> to define an operation <code>&lt;name&gt;</code> where <code>&lt;BIFUNCTION&gt;</code> is a lambda expression with two parameters: the contextual instance or object to which the operation is applied, and list of parameters specified as a map. The keys in the map are the names of the parameters, and the values are the actual arguments. Within the body of the lambda expression, you can access the contextual instance or the arguments map, and must ensure to return a value, either an <code>EObject</code> or a primitive value.</p> GroovyXtendJavaKotlin <pre><code>staticOperation(\"&lt;OperationName&gt;\", { obj, argMap -&gt; // to access the contextual instance use 'obj' \n// to access an argument use 'argMap.&lt;param_name&gt;' \n// must return a value\n})\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\", [ obj, argMap | // to access the contextual instance use 'obj' \n// to access an argument use 'argMap.get(\"&lt;param_name&gt;\")' \n// must return a value\n])\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\", (obj, argMap) -&gt; {\n// to access the contextual instance use 'obj'\n// to access an argument use 'argMap.get(\"&lt;param_name&gt;\")'\n// must return a value\n});\n</code></pre> <pre><code>contextualOperation(\"&lt;OperationName&gt;\") { obj, argMap -&gt;\n// to access the contextual instance use 'obj'\n// to access an argument use 'argMap[\"&lt;param_name&gt;\"]'\n// must return a value\n}\n</code></pre> <p>Contextual operations are invoked on the <code>&lt;ContextualInstance&gt;</code> using the <code>&lt;OperationName&gt;</code> and the list of arguments, specifying the name of the parameter and the actual argument value. While the YAMTL Groovy DSL allows calling the  operation directly, all other programming languages require the <code>fetch</code> operation:</p> GroovyXtendJavaKotlin <pre><code>&lt;OperationName&gt;(&lt;ContextualInstance&gt;, [\"&lt;param1&gt;\" : &lt;value1&gt;, ...])\n</code></pre> <pre><code>&lt;ContextualInstance&gt;.fetch(\"&lt;OperationName&gt;\", #[\"&lt;param1&gt;\" -&gt; &lt;value1&gt;, ...])\n</code></pre> <pre><code>fetch(&lt;ContextualInstance&gt;, \"&lt;OperationName&gt;\", Map.of(\"&lt;param1&gt;\", &lt;value1&gt;, ...));\n</code></pre> <pre><code>fetch(&lt;ContextualInstance&gt;, \"&lt;OperationName&gt;\", mapOf(\"&lt;param1&gt;\" to &lt;value1&gt;, ...))\n</code></pre>"},{"location":"yamtl.html#tomany-rules","title":"ToMany Rules","text":"<p>Matched rules can be declared with the modifier <code>toMany</code> to enable repeated rule applications to the same input object, using <code>toManyCap</code> to indicate how many rule applications should be performed. With <code>toMany</code> rules, the same rule might match the same object multiple times. In such cases, we can reference each match (occurrence 'i' of a match) by the order in which they occurred: <code>fetch(&lt;input_matched_object&gt;, &lt;i&gt;)</code> will return the output object created by the ith match.</p> <p>Declaring a rule with the modifier <code>toMany</code> adds the variable <code>matchCount</code> to the execution environment, which is used to distinguish the different rule applications starting from <code>0</code> for the first application. This variable is available during both pattern matching and transformation execution. This means that the variable <code>matchCount</code> can be used in filter expressions</p> <p>The property <code>toManyCap</code> receives a function of type <code>Supplier&lt;Integer&gt;</code>, which determines the total number of rule applications that should apply to the same match.</p> <p>When declaring rules using rule inheritance together with the modifier <code>toMany()</code>, all rules in the inheritance hierarchy must be <code>toMany()</code>.</p> <p>Differences with Lazy Rules</p> <p>A matched rule that is <code>toMany</code> is scheduled by the tranformation engine and not called on demand. However, when it is matched, the same match is associated with a list of rule applications. While the match is still unique for a particular rule, it is shared among several of the rule applications.</p>"},{"location":"yamtl.html#rule-inheritance","title":"Rule Inheritance","text":"<p>Rule inheritance in YAMTL enables a transformation developer to create a new transformation rule by inheriting the behaviour of multiple existing rules. This mechanism simplifies the transformation process by allowing you to build on existing rule logic without duplicating code, promoting code reuse and encapsulation.</p> <p>The following characteristics define multiple rule inheritance in YAMTL:</p> <ul> <li>Abstract rules: Abstract rules are defined with the clause <code>.isAbstract()</code>. These rules typically act as templates or base rules that other rules can inherit from. These rules are not executed directly and their input/output pattern elements may refer to abstract classes.</li> <li>Concrete rules are rules that are executed if a valid match is found for the input pattern and the output pattern can only refer to concrete classes, i.e., those that can be instantiated in the output model.</li> <li>A descendant rule can inherit from one or several parent rules using the clause <code>inheritsFrom(&lt;ruleNameList&gt;)</code>, where <code>&lt;ruleNameList&gt;</code> is of type <code>List&lt;String&gt;</code>.</li> </ul> <p>When using rule inheritance, rules are expected to be covariant both in input elements and in output elements with respect to inheritance relationships in the corresponding metamodels. When an input or an output element is declared in a parent rule but not declared in a child rule, it is implicitly inherited. The semantics of a transformation rule with respect to inheritance is as follows: </p> <ul> <li>Pattern matching semantics. In matched input elements, filter expressions are inherited using a leftmost top-down evaluation strategy w.r.t. the inheritance hierarchy defined in clauses <code>inheritsFrom(&lt;ruleNameList&gt;)</code>. When an input element <code>in(\"&lt;in_object_name1&gt;\", &lt;in_object_type1&gt;).filter{ &lt;FILTER1&gt; }</code> is declared in a parent rule but it is not declared in a descendant rule, it is inherited. If the input element <code>in(\"&lt;in_object_name1&gt;\", &lt;in_object_type2&gt;).filter{ &lt;FILTER2&gt; }</code> is also defined in a descendant rule, <code>&lt;FILTER2&gt;</code> refines <code>&lt;FILTER1&gt;</code> by adding more constraints. In other words, both <code>&lt;FILTER1&gt;</code> and <code>&lt;FILTER2&gt;</code> must be satisfied by a match for the descendant rule. In addition, <code>&lt;in_object_type2&gt;</code> can be a subclass of <code>&lt;in_object_type1&gt;</code>. In derived input elements, derivation expressions (<code>derivedWith(&lt;QUERY&gt;)</code>) are overriden if they are declared in a descendant rule or simply inherited otherwise.  </li> <li>Transformation execution semantics. In output elements, action expressions are also inherited following a leftmost top-down evaluation strategy w.r.t. the inheritance hierarchy by default. When an output element <code>out(\"&lt;out_object_name&gt;\", &lt;out_object_type1&gt;, { &lt;ACTION1&gt; })</code> in a parent rule is refined by an output element <code>out(\"&lt;out_object_name&gt;\", &lt;out_object_type2&gt;, { &lt;ACTION2&gt; })</code> in a descendant rule, where <code>&lt;in_object_type2&gt;</code> may be a subclass of <code>&lt;in_object_type1&gt;</code>, then both <code>&lt;ACTION1&gt;</code> and <code>&lt;ACTION2&gt;</code> will be executed, in that order. The default behaviour can be overriden by using the qualifier <code>overriding()</code> in the corresponding output element of a descendant rule. When using <code>overriding()</code> in an output element, the parent action <code>&lt;ACTION1&gt;</code> is not executed.</li> </ul> <p>The following table summarizes the errors that YAMTL detects when parsing model transformation rules when rule inheritance is used:</p> Scope Error Description Explanation Resolution Rule Abstract Rule with No Children Rules An abstract rule should have at least one child rule. Define child rules for the abstract rule or consider making it non-abstract if no child rules are intended. Rule Concrete Rule Specialized by an Abstract Rule Occurs when a concrete rule is specialized by an abstract rule, which is not allowed. Ensure that concrete rules are not specialized by abstract rules. Input Incompatible Input Element Types Occurs when an input element's type in a descendant rule is not a subtype of the same input element's type in a parent rule. Make sure that the types of input elements in the descendant rule are compatible with those in the parent rule. Input Mismatched Nature of Input Elements Occurs when an input element's nature (matched/derived) differs between a rule and its parent rule. Ensure that the nature of input elements is consistent between the descendant rule and its parent rule. Input Input Element Inherited from Two Separate Parent Rules An input element cannot be inherited from two separate parent rules. Avoid inheriting the same input element from two separate parent rules to prevent conflicts. Output Output Element Declared as 'Overriding' with No Parent Rule Occurs when an output element is declared as 'overriding', but there is no parent rule to override. Remove the 'overriding' declaration or ensure that the rule has a valid parent rule. Output Incompatible Output Element Types Occurs when an output element's type in a descendant rule is not a subtype of the same output element's type in a parent rule. Ensure that the types of output elements in the descendant rule are compatible with those in the parent rule. Output Output Element Declared as 'Drop' with No Valid Input Element Occurs when an output element is declared as 'drop', but it does not refer to a valid input element. Check that the 'drop' declaration references a valid input element, or remove it if unnecessary. Output Output Element Inherited from Two Parent Rules with Different Types An output element cannot be inherited from two parent rules with incompatible types; this results in an error. Ensure that the types of inherited output elements are compatible between parent rules. Output Rule Inherits the Same Output Element from Two Parent Classes When a rule inherits the same output element from two parent classes, it's a potential issue, and a warning is issued. Review the rule's inheritance structure and consider if it leads to unintended behavior. <p>When a descendant rule inherits the same output element from two different parent rules, situation known as the diamond problem, YAMTL detects the situation and warns the user but the model transformation proceeds using inheritance semantics as explained above.</p> <p>Tip</p> <p>During pattern matching, YAMTL selects the most generic rules first. When a match is found for the parent rule, it then processes the match with the input pattern of the descendant rules using a depth-first strategy.</p> <p>Info</p> <p>In the original YAMTL semantics, YAMTL supported multiple rule inheritance in both input patterns and output patterns. Since version 0.3.6, multiple inheritance only applies to output patterns in rules. This feature has been deprecated to facilitate more concise syntax when specifying input patterns in rules.</p>"},{"location":"yamtl.html#module-composition","title":"Module Composition","text":"<p>YAMTL modules can be imported and used in other Xtend/Java/Groovy classes by creating instances of their main classes. This allows you to reuse the functionality provided by a YAMTL module within your code. A YAMTL module can also incorporate any Java Virtual Machine (JVM) library, extending its functionality by using external code.</p> <p>Module extension is used for composing modules i.e. creating a subclass of an existing module to extend the capabilities of the base module. When YAMTL modules are extended, the process of initializing rules and attribute helpers begins from the root modules (those that do not extend any other module). Initialization then proceeds along the hierarchy of extended modules, moving from parent modules to their descendants.</p> <p>When a specializing module declares a rule that is already defined in the parent module (by name), the new rule overrides the existing one. Rules in the parent module can also be extended using rule inheritance.</p>"},{"location":"yamtl.html#incremental-model-to-model-transformations","title":"Incremental Model-to-Model Transformations","text":"<p>By default model-to-model transformations in YAMTL transformations are executed in batch mode, where the entire input model is read and a new output model is produced from scratch. However, this approach can be inefficient when dealing with large models or when only a small portion of the model undergoes changes. To address this limitation, incremental model-to-model transformations have emerged as a more efficient alternative.</p> <p>Incremental model-to-model transformations in YAMTL extend the capabilities of standard transformations by maintaining a relationship between the source and target models. Rather than reprocessing the entire model, these transformations update only the parts of the target model that correspond to changed elements in the source model. This results in an increase in computational efficiency, particularly in scenarios where models are large, or changes are frequent but localized. </p> <p>Incremental transformations are commonly used in the following scenarios:</p> <ul> <li>Real-Time Systems: In real-time systems where immediate responsiveness is essential, incremental transformations can deliver results more rapidly.</li> <li>Collaborative Modeling: In environments where multiple individuals are modifying a model simultaneously, incremental transformations help maintain a coherent and updated version of the target model.</li> <li>Continuous Integration: Incremental transformations are beneficial for continuous development pipelines that require constant model updates.</li> </ul> <p>YAMTL support for the incremental evaluation of model transformations relies on the following components:</p> <ul> <li>Tracking transformation steps. Every application of a transformation rule to an input model constitutes a transformation step, which associates an input match with a corresponding output match.  In YAMTL, this tracking occurs implicitly, eliminating the need for user-initiated manual intervention. YAMTL also supports explicit mechanisms for tracking transformation steps.</li> <li>Tracking feature calls. Structural features in the input model, typically corresponding to objects matched by the input pattern of a rule, are employed for computations within <code>&lt;FILTER&gt;</code>, <code>&lt;QUERY&gt;</code>, or <code>&lt;ACTION&gt;</code> blocks. YAMTL can identify the usage of an accessor method that commences with the get prefix to access a structural feature of an object in the input model. This detection is facilitated through aspect-oriented programming. To enable this functionality, the user must configure the YAMTLModule with the namespace containing the input model's classes. This is accomplished via the configuration option xform.adviseWithinThisNamespaceExpressions(<code>&lt;namespaceList&gt;</code>);, where xform is the YAMTLModule containing rule definitions, and <code>&lt;namespaceList&gt;</code>, of type <code>List&lt;String&gt;</code>, enumerates the namespaces to be instrumented with aspects. A namespace may be specified as a fully qualified package name, such as com.a.y, or may encompass a set of packages using <code>..*</code>, like  <code>com.a.y.*</code>, which includes package <code>com.a.y</code> and its direct subpackages, or <code>com.a.y..*</code>, which includes package <code>com.a.y</code> and all its subpackages.</li> <li>Tracking changes in a model. Model changes can be classified into two categories: on-the-fly and offline changes. On-the-fly changes involve real-time modifications to the objects within a model in memory, whereas offline changes pertain to the application of a distinct model describing these alterations. YAMTL employs the EMF Adapter Framework for handling on-the-fly modifications, and utilises the EMF Change Model for processing offline changes. The EMF Change Model is equipped with a change recorder that is capable of serialising the in-memory change description model in XMI format.</li> </ul> <p>The execution of an incremental model transformation in YAMTL is performed in two stages:</p> <ul> <li>Initial stage. The model transformation is executed in batch mode and YAMTL stores transformation steps.</li> <li>Change propagation stage. Given a source model change (either on-the-fly or offline), YAMTL analyses the impact of the change on the model transformation and only re-evaluates those transformation steps that are affected.</li> </ul>"},{"location":"yamtl.html#template-to-execute-model-transformations","title":"Template to execute model transformations","text":"<p>The following example code snippets illustrate how to configure and execute a transformation in YAMTL using different programming languages.</p>"},{"location":"yamtl.html#using-on-the-fly-changes","title":"Using On-the-Fly Changes","text":"<p>The code snippets below ilustrate how to execute a model transformation in incremental mode, making a change to the input model once it has been transformed with <code>YAMTLModule::execute()</code>. </p> GroovyXtendJavaKotlin <pre><code>// CONFIGURATION\ndef xform = new XForm()\nYAMTLGroovyExtensions.init(this)        xform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\")\n/* CHANGES TO MODEL HERE */\nxform.propagateDelta(\"&lt;in_domain_name&gt;\")\nxform.saveOutputModels([\"&lt;out_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>// CONFIGURATION\nval xform = new XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(#{'&lt;in_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n// INITIAL TRANSFORMATION\nxform.execute\n// DELTA PROPAGATION\nxform.adaptInputModel('&lt;in_domain_name&gt;')\n// CHANGES TO MODEL HERE\nxform.propagateDelta('&lt;in_domain_name&gt;')\nxform.saveOutputModels(#{'&lt;out_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n</code></pre> <pre><code>// CONFIGURATION\nXForm xform = new XForm();\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.setExecutionMode(ExecutionMode.INCREMENTAL);\nxform.loadInputModels(Map.of(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n// INITIAL TRANSFORMATION\nxform.execute();\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\");\n// CHANGES TO MODEL HERE\nxform.propagateDelta(\"&lt;in_domain_name&gt;\");\nxform.saveOutputModels(Map.of(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>// CONFIGURATION\nval xform = XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.setExecutionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.adaptInputModel(\"&lt;in_domain_name&gt;\")\n// CHANGES TO MODEL HERE\nxform.propagateDelta(\"&lt;in_domain_name&gt;\")\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>Incremental transformations are activated by setting the execution mode to <code>ExecutionMode.INCREMENTAL</code>.</p> <p>The YAMTL engine is instructed on the locations for instrumenting <code>getter</code> methods through the statement <code>xform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)</code>, specifying the pertinent package names.</p> <p>For change tracking, the <code>xform.adaptInputModel(\"&lt;in_domain_name&gt;\")</code> statement is used to instrument the input model with EMF adapters. It is important to abstain from adapting the model prior to invoking <code>execute()</code>, in order to minimise the extent of changes requiring monitoring. Changes are made by accessing objects in the <code>Resource</code> of the input model, which can be accessed using <code>xform.getModelResource(\"&lt;in_domain_name&gt;\")</code>, and applying changes to their structural features.</p> <p>Subsequently, the <code>xform.propagateDelta(\"&lt;in_domain_name&gt;\")</code> statement facilitates the propagation of any changes made from the input model to the output model.</p>"},{"location":"yamtl.html#using-offline-changes","title":"Using Offline Changes","text":"GroovyXtendJavaKotlin <pre><code>// CONFIGURATION\ndef xform = new XForm()\nYAMTLGroovyExtensions.init(this)        xform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels([\"&lt;in_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels([\"&lt;out_domain_name&gt;\": \"&lt;path_to_model&gt;\"])\n</code></pre> <pre><code>// CONFIGURATION\nval xform = new XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(#{'&lt;in_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n// INITIAL TRANSFORMATION\nxform.execute\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels(#{'&lt;out_domain_name&gt;' -&gt; '&lt;path_to_model&gt;'})\n</code></pre> <pre><code>// CONFIGURATION\nXForm xform = new XForm();\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;);\nxform.setExecutionMode(ExecutionMode.INCREMENTAL);\nxform.loadInputModels(Map.of(\"&lt;in_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n// INITIAL TRANSFORMATION\nxform.execute();\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\");\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\");\nxform.saveOutputModels(Map.of(\"&lt;out_domain_name&gt;\", \"&lt;path_to_model&gt;\"));\n</code></pre> <pre><code>// CONFIGURATION\nval xform = XForm()\nxform.adviseWithinThisNamespaceExpressions(&lt;namespaceList&gt;)\nxform.executionMode = ExecutionMode.INCREMENTAL\nxform.loadInputModels(mapOf(\"&lt;in_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n// INITIAL TRANSFORMATION\nxform.execute()\n// DELTA PROPAGATION\nxform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")\nxform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")\nxform.saveOutputModels(mapOf(\"&lt;out_domain_name&gt;\" to \"&lt;path_to_model&gt;\"))\n</code></pre> <p>The primary distinction when employing offline changes lies in the provision of changes to the input model via a change description model, as defined by the EMF Change Model2. The statement <code>xform.loadDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\", \"&lt;path/to/delta/file.xmi&gt;\")</code> loads the change stored at <code>&lt;path/to/delta/file.xmi&gt;</code>, subsequently associating it with the input model identified by <code>&lt;in_domain_name&gt;</code> and a user-defined name <code>&lt;deltaName&gt;</code>.</p> <p>For the propagation of this change, it first needs to be applied to the input model and then needs to be propagated to the output model. This is achieved via the statement <code>xform.applyAndPropagateDelta(\"&lt;in_domain_name&gt;\", \"&lt;deltaName&gt;\")</code>.</p>"},{"location":"yamtl.html#incrementality-granularity","title":"Incrementality granularity","text":"<p>YAMTL is an internal DSL of JVM programming languages and specific design decisions have been made in order to reuse as much syntax from the underlying host programming language as possible. In particular, assignments of values to object features (attributes and references) are handled by the assignment statement in the host language.</p> <p>In general terms, YAMTL checks whether a change invalidates the match of an existing transformation step. If the match is no longer valid, the transformation step is undone. Otherwise, the transformation step will be re-executed according to the following levels of granularity:</p> <ul> <li>Tranformation step granularity (<code>IncrementalGranularity.TRAFO_STEP</code>): When a change impacts any part of a transformation step, the match whole transformation step is re-executed. This is the default granularity level.</li> <li>Element granularity (<code>IncrementalGranularity.ELEMENT</code>): This is a more refined mode in which YAMTL detects whether a change only affects a particular <code>in</code> or <code>out</code> element. YAMTL only re-evaluates the filters of affected <code>in</code> elements and the actions of affected <code>out</code> elements.</li> </ul> <p>The granularity of the incremental evaluation scope is set using the flag <code>YAMTLModule::incrementalGranularity</code>. By default, it is set to <code>IncrementalGranularity.TRAFO_STEP</code> and it can be set to <code>IncrementalGranularity.ELEMENT</code>.</p>"},{"location":"yamtl.html#undo","title":"Undo","text":"<p>Todo</p>"},{"location":"yamtl.html#implicit-vs-explicit-traceability","title":"Implicit vs explicit traceability","text":"<p>Todo</p>"},{"location":"yamtl.html#examples","title":"Examples","text":"<ul> <li> <p>The Linked list reversal example reverses a linked list data structure originally stored in XMI format (source model). YAMTL transformation generates an <code>outputList.xmi</code> containing the target model. Both source and target metamodels are created using the same ECore file since the data structure remains the same after the transformation. A Gradle test runs a Groovy script that loads the input model, executes the transformation, and saves the output model.</p> </li> <li> <p>Flowchart to HTML project looks at transforming flowchart models into valid HTML documents. This project specifically has multiple transformation examples that cover a wide range of YAMTL operations, annotations, and core concepts. This project is perfect for readers who want to take the next step in learning more about the complete functionality of each MTL tool in well-documented bite-sized examples.</p> </li> </ul>"},{"location":"yamtl.html#trade-offs-regarding-performance","title":"Trade-offs regarding performance","text":"<p>Todo</p> <ul> <li>Groovy vs Xtend/Java: Groovy offers a more readable syntax</li> <li>SpringAOP vs AspectJ: SpringAOP simplifies configuration</li> </ul> <ol> <li> <p>Hana Mkaouar, Dominique Blouin, Etienne Borde: A benchmark of incremental model transformation tools based on an industrial case study with AADL. Softw. Syst. Model. 22(1): 175-201 (2023)\u00a0\u21a9</p> </li> <li> <p>David Steinberg, Frank Budinsky, Marcelo Paternostro, and Ed Merks. 2009. EMF: Eclipse Modeling Framework 2.0 (2nd. ed.). Addison-Wesley Professional.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/flowchart-to-html-example.html","title":"Flowchart to HTML","text":""},{"location":"examples/flowchart-to-html-example.html#problem-description","title":"Problem Description","text":"<p>In this example, we will look at converting flowchart elements into HTML elements. The problem is open-ended, meaning, there is no one solution but rather the project will contain many small examples that showcase a multitude of operations for each documented MTL. The flowchart which should be used as the source model of the project is depicted in the diagram below:</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>Here is how the different models in this project depend on each other:</p> <p><pre><code>graph BT\n    B[Source Model] --&gt;|conforms to| A[Flowchart Metamodel];\n    C[MT Execution Engine] --&gt;|reads| B;\n    C --&gt;|executes| D[MT Definition];\n    C --&gt;|writes| E[Target Model];\n    D --&gt;|uses| A;\n    E --&gt;|conforms to| F[HTML Metamodel];\n    D --&gt;|uses| F;</code></pre> </p> Dependencies of the project files <p>Now, let's see how the models are defined.</p>"},{"location":"examples/flowchart-to-html-example.html#source-metamodel","title":"Source Metamodel","text":"<p>The source metamodel is defined using Emfatic (.emf), which can be converted into an <code>ECore</code> file. You can then access the flowchart classes as <code>EPackage</code>s (<code>ECore</code> has <code>EClasses</code> which are referenced as <code>EPackage</code> in Groovy) to be used within the MT definition. </p> <pre><code>@namespace(uri=\"flowchart\", prefix=\"flowchart\")\npackage flowchart;\n\nabstract class NamedElement {\n    attr String name;\n}\n\nclass Flowchart extends NamedElement {\n   val Node[*] nodes;\n   val Transition[*] transitions;\n}\n\nabstract class Node extends NamedElement {\n   ref Transition[*]#source outgoing;\n   ref Transition[*]#target incoming;\n}\n\nclass Transition extends NamedElement {\n   ref Node#outgoing source;\n   ref Node#incoming target;\n}\n\nclass Action extends Node {\n\n}\n\nclass Decision extends Node {\n\n}\n\nclass Subflow extends Flowchart, Node {\n\n}\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#target-metamodel","title":"Target Metamodel","text":"<p>Just like before, the target metamodel is also defined using Emfatic. The metamodel script is long because all HTML elements must be defined so that the transformation generates a valid HTML document.</p> <pre><code>package HTML;\n\n  class HTML {\n    !ordered val HEAD#html head;\n    !ordered val BODY#html body;\n  }\n\n  class HTMLElement {\n    !unique !ordered attr EString value;\n    !ordered val HTMLElement[*] children;\n  }\n\n  class HEAD extends HTMLElement {\n    !ordered val HEADElement[*]#head headElements;\n    !ordered ref HTML#head html;\n  }\n\n  abstract class HEADElement extends HTMLElement {\n    !ordered ref HEAD#headElements head;\n  }\n\n  class LINK extends HEADElement {\n    !unique !ordered attr EString rel;\n    !unique !ordered attr EString title;\n    !unique !ordered attr EString ahref;\n    !unique !ordered attr EString type;\n  }\n\n  class TITLE extends HEADElement {\n  }\n\n  class BODY extends HTMLElement {\n    !unique !ordered attr EString background;\n    !unique !ordered attr EString bgcolor;\n    !unique !ordered attr EString text;\n    !unique !ordered attr EString link;\n    !unique !ordered attr EString alink;\n    !unique !ordered attr EString vlink;\n    !ordered val BODYElement[*] bodyElements;\n    !ordered ref HTML#body html;\n  }\n\n  abstract class BODYElement extends HTMLElement {\n  }\n\n  class H1 extends BODYElement {\n  }\n\n  class H2 extends BODYElement {\n  }\n\n  class H3 extends BODYElement {\n  }\n\n  class H4 extends BODYElement {\n  }\n\n  class EM extends BODYElement {\n  }\n\n  class STRONG extends BODYElement {\n  }\n\n  class B extends BODYElement {\n  }\n\n  class I extends BODYElement {\n  }\n\n  class TT extends BODYElement {\n  }\n\n  class PRE extends BODYElement {\n  }\n\n  class BIG extends BODYElement {\n  }\n\n  class SMALL extends BODYElement {\n  }\n\n  class SUB extends BODYElement {\n  }\n\n  class SUP extends BODYElement {\n  }\n\n  class STRIKE extends BODYElement {\n  }\n\n  class FONT extends BODYElement {\n    !unique !ordered attr EString color;\n    !unique !ordered attr EString face;\n    !unique !ordered attr EString size;\n  }\n\n  class IMG extends BODYElement {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n    !unique !ordered attr EString alt;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString vspace;\n    !unique !ordered attr EString hspace;\n    !unique !ordered attr EString ismap;\n    !unique !ordered attr EString usemap;\n    !unique !ordered attr EString border;\n  }\n\n  class BR extends BODYElement {\n    !unique !ordered attr EString clear;\n  }\n\n  class MAP extends BODYElement {\n  }\n\n  class AREA extends BODYElement {\n    !unique !ordered attr EString shape;\n    !unique !ordered attr EString coords;\n    !unique !ordered attr EString ahref;\n  }\n\n  class STYLE extends BODYElement {\n  }\n\n  class EMBED extends BODYElement {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString vspace;\n    !unique !ordered attr EString hspace;\n    !unique !ordered attr EString border;\n  }\n\n  class NOEMBED extends BODYElement {\n  }\n\n  class SPAN extends BODYElement {\n    !unique !ordered attr EString style;\n  }\n\n  class A extends BODYElement {\n    !unique !ordered attr EString ahref;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString ~id;\n  }\n\n  class DIV extends BODYElement {\n    !unique !ordered attr EString align;\n  }\n\n  class P extends BODYElement {\n  }\n\n  abstract class TABLEElement extends BODYElement {\n    !unique !ordered attr EString bgcolor;\n    !unique !ordered attr EString background;\n  }\n\n  class TABLE extends TABLEElement {\n    !unique !ordered attr EString border;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString cellspacing;\n    !unique !ordered attr EString cellpadding;\n    !ordered val TR[*]#table trs;\n  }\n\n  class TR extends TABLEElement {\n    !unique !ordered attr EString valign;\n    !unique !ordered attr EString align;\n    !ordered ref TABLE#trs table;\n    !ordered val TD[*]#tr tds;\n  }\n\n  class TD extends TABLEElement {\n    !unique !ordered attr EString colspan;\n    !unique !ordered attr EString rowspan;\n    !unique !ordered attr EString valign;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString width;\n    !ordered ref TR#tds tr;\n  }\n\n  class TH extends TD {\n  }\n\n  class FORM {\n    !unique !ordered attr EString action;\n    !unique !ordered attr EString method;\n  }\n\n  class INPUT {\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString maxlength;\n    !unique !ordered attr EString size;\n    !unique !ordered attr EString checked;\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString inputValue;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString type;\n  }\n\n  class TEXTAREA {\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString rows;\n    !unique !ordered attr EString cols;\n  }\n\n  class SELECT {\n    !unique !ordered attr EString multiple;\n    !unique !ordered attr EString size;\n    !unique !ordered attr EString name;\n  }\n\n  class OPTION {\n    !unique !ordered attr EString selected;\n    !unique !ordered attr EString optionValue;\n  }\n\n  abstract class ListElement {\n    !unique !ordered attr EString type;\n  }\n\n  class OL extends ListElement {\n    !unique !ordered attr EString start;\n  }\n\n  class UL extends ListElement {\n  }\n\n  class LI extends ListElement {\n    !unique !ordered attr EString liValue;\n  }\n\n  class DL {\n  }\n\n  class DT {\n  }\n\n  class DD {\n  }\n\n  class APPLET {\n    !unique !ordered attr EString applet;\n    !unique !ordered attr EString ~class;\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString align;\n    !unique !ordered attr EString width;\n    !unique !ordered attr EString height;\n  }\n\n  class PARAM {\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString paramValue;\n  }\n\n  class OBJECT {\n    !unique !ordered attr EString classid;\n    !unique !ordered attr EString ~id;\n    !unique !ordered attr EString data;\n    !unique !ordered attr EString type;\n    !unique !ordered attr EString standby;\n  }\n\n  class FRAMESET {\n    !unique !ordered attr EString rows;\n    !unique !ordered attr EString cols;\n    !unique !ordered attr EString framespacing;\n    !unique !ordered attr EString frameborder;\n    !unique !ordered attr EString border;\n  }\n\n  class FRAME {\n    !unique !ordered attr EString src;\n    !unique !ordered attr EString name;\n    !unique !ordered attr EString marginwidth;\n    !unique !ordered attr EString marginheight;\n    !unique !ordered attr EString scrolling;\n    !unique !ordered attr EString noresize;\n  }\n\n  class NOFRAME {\n  }\n\n  class IFRAME extends FRAME {\n  }\n\n// Based on https://github.com/SATToSE/SoTeSoLa2012/blob/master/hackathon/modisco-eclipse/org.eclipse.gmt.modisco.tool.metricsvisualizationbuilder/Metamodels/HTML.ecore\n</code></pre>"},{"location":"examples/flowchart-to-html-example.html#source-model","title":"Source Model","text":"<p>A sample source model representing the flowchart (can be altered in an MTL solution) in Flexmi format is as follows: <pre><code>&lt;flowchart&gt;\n    &lt;action name=\"Wake up\" incoming=\"some time passes, start\" outgoing=\"\"/&gt;\n    &lt;decision name=\"Is it too early?\" incoming=\"\" outgoing=\"yes, no\"/&gt;\n    &lt;action name=\"Sleep\" incoming=\"yes\" outgoing=\"some time passes\"/&gt;\n    &lt;action name=\"Get up\" incoming=\"no\"/&gt;\n    &lt;action name=\"begin\" outgoing=\"start\"/&gt;\n    &lt;transition source=\"Wake up\" target=\"Is it too early?\"/&gt;\n    &lt;transition name=\"yes\" source=\"Is it too early?\" target=\"Sleep\"/&gt;\n    &lt;transition name=\"some time passes\" source=\"Sleep\" target=\"Wake up\"/&gt;\n    &lt;transition name=\"no\" source=\"Is it too early?\" target=\"Get up\"/&gt;\n    &lt;transition name=\"start\" source=\"begin\" target=\"Wake up\"/&gt;\n&lt;/flowchart&gt;\n</code></pre></p>"},{"location":"examples/flowchart-to-html-example.html#target-model","title":"Target Model","text":"<p>Since the problem is open-ended there is no one solution i.e. no final target model to achieve. Check out the MTL Solutions below to see the advanced functionalities (special operations and concepts) of each MTL.</p>"},{"location":"examples/flowchart-to-html-example.html#mtl-solutions","title":"MTL Solutions","text":"<ul> <li>ETL</li> <li>YAMTL</li> </ul>"},{"location":"examples/linked-list-reversal-example.html","title":"Linked List Reversal","text":""},{"location":"examples/linked-list-reversal-example.html#problem-description","title":"Problem Description","text":"<p>Let's see a simple example where a linked list with 2 nodes (N1 and N2) is reversed through model transformation.</p> <p>A linked list is a collection of sequentially connected nodes where each node contains some data and a reference (pointer) to the next node. The head of a linked list is the first node of the list i.e. the node that is not being referenced. The node at the end (tail) cannot point to the next node hence it references to <code>null</code>. A regular linked list comprises of these characteristics, so, we need to just change them appropriately to reverse the order of the nodes.</p> <p>Source Model</p> <p> </p> Linked list BEFORE transformation <p>Target Model</p> <p> </p> Linked list AFTER transformation <p></p> <p>You will need to understand this example's project structure before you read any line of code:</p> <p><pre><code>graph BT\n    B[Source Model] --&gt;|conforms to| A[Linked List Metamodel];\n    C[MT Execution Engine] --&gt;|reads| B;\n    C --&gt;|writes| D[Target Model];\n    C --&gt;|executes| E[MT Definition];\n    E --&gt;|uses| A;\n    D --&gt;|conforms to| A;</code></pre> </p> Dependencies of the project files <p>This example slightly differs from general model transformation projects because the source and target metamodels are the same (as seen in the figure above). The model transformation definition (MT Definition) must adhere to the MTL syntax and semantics, so it has been documented separately for each MTL provided in the MTL Solutions section at the bottom of this page. Next, we will look at other important files required for the model transformation.</p>"},{"location":"examples/linked-list-reversal-example.html#metamodel","title":"Metamodel","text":"<p>The source and target model must conform to the linked list metamodel. This contains the necessary information regarding the structure of the linked list at an abstract level such that certain characteristics of the linked list can still be changed in the model files. Look at the pseudocode below for the linked list metamodel:</p> Metamodel Pseudocode<pre><code>CLASS Linked List\n        SET reference to a Node object as HEAD\n        INIT LIST of Node objects\n\nCLASS Node\n        INIT string DATA attribute\n        SET reference to the NEXT Node object in the linked list \n</code></pre> <p>The metamodel contains two class definitions for <code>Linked List</code> and <code>Node</code> objects. The <code>Linked List</code> class has a <code>HEAD</code> attribute (as a reference) and a <code>LIST</code> of <code>Node</code> objects are initialised. The <code>Node</code> object contains a <code>DATA</code> field of the 'String' data type and a pointer (reference) to the <code>NEXT</code> object of the same type (<code>Node</code>) in the list.</p>"},{"location":"examples/linked-list-reversal-example.html#source-model","title":"Source Model","text":"<p>A sample source model (generally in XMI format) would look like the snippet below:</p> Sample Source Model in Flexmi<pre><code>&lt;LinkedList head=\"N1\"&gt;\n    &lt;node name=\"N1\" next=\"N2\"/&gt;\n    &lt;node name=\"N2\"/&gt;\n&lt;/LinkedList&gt;\n</code></pre>"},{"location":"examples/linked-list-reversal-example.html#target-model","title":"Target Model","text":"<p>A sample target model (also generally in XMI format) which is generated by performing a rule-based transformation on the source model would look like this:</p> Sample Target Model in Flexmi<pre><code>&lt;LinkedList head=\"N2\"&gt;\n    &lt;node name=\"N1\"/&gt;\n    &lt;node name=\"N2\" next=\"N1\"/&gt;\n&lt;/LinkedList&gt;\n</code></pre>"},{"location":"examples/linked-list-reversal-example.html#mtl-solutions","title":"MTL Solutions","text":"<ul> <li>ETL</li> <li>YAMTL</li> </ul>"},{"location":"tutorials/etl-flowchart-to-html.html","title":"Flowchart to HTML - ETL Implementation","text":"<p>In this tutorial, the core concepts of ETL transformations will be described. To do this, elements of a flowchart model will be transformed using special operations into valid HTML elements.</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>The flowchart model (abstract representation shown in the figure above) has different types of elements: Node, Action, Decision, Transition, and Subflow.</p> <p>Node elements are the most basic elements in a flowchart. They can have any number of incoming and outgoing transitions.</p> <p>Action elements are a type of Node element. They have a value describing an action and such elements can also have any number of incoming and outgoing transitions.</p> <p>Decision elements are another type of Node element. Its value indicates a decision (if-else condition) and a decision element can have any number of incoming and outgoing transitions.</p> <p>Transition elements are those arrows (direction flow) in the flowchart figure above. They have a name attribute. A transition element must have one source Node (start of the arrow) and one target Node (end of the arrow).</p> <p>Subflow is a special Node element that contains a flowchart inside a flowchart (making it a sub-section). A subflow element has a name and all the features of a flowchart i.e. can have any number of nodes and transitions.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#source-metamodel","title":"Source Metamodel","text":"<p>This is the flowchart metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#target-metamodel","title":"Target Metamodel","text":"<p>This is the HTML metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#source-model","title":"Source Model","text":""},{"location":"tutorials/etl-flowchart-to-html.html#wakeup-flowchart","title":"Wakeup Flowchart","text":"<p>The flowchart diagram can be represented in Flexmi with some changes (outgoing and incoming transitions of <code>Node</code> elements are removed because they cause syntactical errors for nodes with multiple transitions):</p> <pre><code>&lt;flowchart&gt;\n    &lt;action name=\"Wake up\"/&gt;\n    &lt;decision name=\"Is it too early?\"/&gt;\n    &lt;action name=\"Sleep\"/&gt;\n    &lt;action name=\"Get up\"/&gt;\n    &lt;transition source=\"Wake up\" target=\"Is it too early?\"/&gt;\n    &lt;transition name=\"yes\" source=\"Is it too early?\" target=\"Sleep\"/&gt;\n    &lt;transition name=\"some time passes\" source=\"Sleep\" target=\"Wake up\"/&gt;\n    &lt;transition name=\"no\" source=\"Is it too early?\" target=\"Get up\"/&gt;\n&lt;/flowchart&gt;\n</code></pre>"},{"location":"tutorials/etl-flowchart-to-html.html#wakeup-flowchart-with-subflow","title":"Wakeup Flowchart with Subflow","text":"<p>Some MTL examples also transform the Flowchart's subflow elements, so, another flowchart (that contains subflow) based on the original flowchart is also defined. The flowchart model with subflow is as follows:</p> <p>Graphical Representation</p> <p></p> <p>Abstract Syntax in Flexmi</p> <pre><code>&lt;flowchart&gt;\n    &lt;action name=\"Wake up\"/&gt;\n    &lt;action name=\"Get up\"/&gt;\n    &lt;action name=\"Begin\"/&gt;\n    &lt;subflow name=\"Snoozing\"&gt;\n        &lt;action name=\"Sleep\"/&gt;\n        &lt;decision name=\"Is it too early?\"/&gt;\n        &lt;transition name=\"Yes\" source=\"Is it too early?\" target=\"Sleep\"/&gt;\n    &lt;/subflow&gt;\n    &lt;transition source=\"Wake up\" target=\"Is it too early?\"/&gt;\n    &lt;transition name=\"Some time passes\" source=\"Sleep\" target=\"Wake up\"/&gt;\n    &lt;transition name=\"No\" source=\"Is it too early?\" target=\"Get up\"/&gt;\n    &lt;transition name=\"Start\" source=\"Begin\" target=\"Wake up\"/&gt;\n&lt;/flowchart&gt;\n</code></pre>"},{"location":"tutorials/etl-flowchart-to-html.html#transformation-examples","title":"Transformation Examples","text":""},{"location":"tutorials/etl-flowchart-to-html.html#base-example","title":"Base Example","text":"<p>This ETL definition converts a flowchart model to an HTML document. Specifically, it turns all flowchart elements and sub-elements into headings. Each of the 4 rules only transform one type of element. The <code>Flowchart2Heading</code> rule transforms all flowchart elements into headings. The <code>Action2Heading</code> rule transforms all action elements into headings. The <code>Decision2Heading</code> rule transforms all decision elements into headings. The <code>Transition2Heading</code> rule transforms all transition elements into headings.</p> <pre><code>//This rule transforms all flowchart elements to headings\nrule Flowchart2Heading\n    transform f : Source!Flowchart\n    to h1 : Target!H1 {\n\n    h1.value = f.name;\n}\n\n//This rule transforms all action elements to headings\nrule Action2Heading\n    transform a : Source!Action\n    to h1 : Target!H1 {\n\n    h1.value = a.name;\n}\n\n//This rule transforms all decision elements to headings\nrule Decision2Heading\n    transform d : Source!Decision\n    to h1 : Target!H1 {\n\n    h1.value = d.name;\n}\n\n//This rule transforms all transition elements to headings\nrule Transition2Heading\n    transform t : Source!Transition\n    to h1 : Target!H1 {\n\n    h1.value = t.name;\n}\n</code></pre> <p>Each of the rules defined above follow the same structure. The <code>transform</code> clause defines an input object with a type from the source metamodel. The <code>to</code> clause defines an output object with a type from the target metamodel. The <code>to</code> statment is followed by EOL statement(s) enclosed in curly braces. The EOL statements define the transformation logic. In this case, the transformation logic is to assign the name of the input element to the value of the output element.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#inheritance","title":"Inheritance","text":"<p>Inheritance in ETL allows you to reuse the same transformation logic for different elements. In the example below, the <code>Flowchart2H1</code> rule is abstract and is extended by the <code>Subflow2H1</code> rule. The <code>Subflow2H1</code> rule inherits the transformation logic of the <code>Flowchart2H1</code> rule and adds its transformation logic.</p> <pre><code>// If we make the following rule abstract, then only\n// subflows will be transformed.\n@abstract\nrule Flowchart2H1\n    transform e : Source!Flowchart\n    to h1 : Target!H1 {\n\n    //Assigns the name of the flowchart to the value of the h1 element\n    h1.value = \"Flowchart \" + e.name; \n}\n\n//Transform subflows into headings\nrule Subflow2H1\n    transform e : Source!Subflow\n    to h1 : Target!H1\n    extends Flowchart2H1 { //Subflow2H1 inherits from Flowchart2H1\n\n    h1.value = \"Subflow \" + h1.value;\n}\n</code></pre> <p>When the <code>Flowchart2H1</code> rule is abstract, only subflows will be transformed and output in the target model. When the <code>Flowchart2H1</code> rule is not abstract, all flowchart elements will be transformed. In this case, the <code>Subflow2H1</code> rule inherits from <code>Flowchart2H1</code> and substitutes the name of <code>e</code> input element (<code>e.name</code>) into the parent rule (note <code>e</code> input element is the same as <code>e</code> input element in the parent rule). Since <code>Subflow2H1</code> rule extends <code>Flowchart2H1</code> rule, the parent rule is also executed and the <code>e</code> element from the child is passed to the parent rule during execution, causing the value of <code>h1</code> in the parent rule to be \"Flowchart Snoozing\". This is also reflected when the <code>Subflow2H1</code> rule's output pattern is executed and its <code>h1</code> value will be \"Subflow Flowchart Snoozing\". </p>"},{"location":"tutorials/etl-flowchart-to-html.html#lazy-execution","title":"Lazy Execution","text":"<p>Lazy rules are those which are invoked only if their output is requested by another rule using an equivalent operation. The intended purpose is to manage the execution of different rules, and restrict executing only those lazy rules whose output needs to be accessed by some other rule. With regards to rule priority, lazy rules are invoked after all non-lazy rules have been executed. In the example below, the <code>Action2Heading</code> and <code>Decision2Heading</code> rules are lazy and are invoked (in top-down order) after the <code>Flowchart2Heading</code> rule has been executed.</p> <pre><code>rule Flowchart2Heading\n    transform f : Source!Flowchart\n    to div : Target!DIV {\n\n    div.children.addAll(f.nodes.equivalent());\n}\n\n// Lazy rules are invoked only when their output is \n// requested by some other rule using equivalent() or ::=\n@lazy\nrule Action2Heading \n    transform a : Source!Action\n    to h1 : Target!H1 {\n\n    h1.value = a.name;\n}\n\n@lazy\nrule Decision2Heading \n    transform d : Source!Decision\n    to h1 : Target!H1 {\n\n    h1.value = d.name;\n}\n\n// Note that the following rule is never invoked\n@lazy\nrule Transition2Heading \n    transform t : Source!Transition\n    to h1 : Target!H1 {\n\n    h1.value = t.name;\n}\n</code></pre> <p>In this example, three rules have been annotated as <code>@lazy</code>. However, only 2 of them (<code>Action2Heading</code> and <code>Decision2Heading</code>) are invoked. This is because lazy rules can only be applied if their result is requested using a <code>fetch()</code> operation (or <code>::=</code>) from another rule. <code>Action</code> and <code>Decision</code> elements inherit from <code>Node</code> elements. The <code>Flowchart2Heading</code> rule uses the <code>f.nodes.equivalent()</code> operation to fetch all <code>Node</code> elements (including <code>Action</code> and <code>Decision</code> elements) and transform them into <code>H1</code> elements. The <code>Transition2Heading</code> rule is never invoked because the <code>Flowchart2Heading</code> rule does not fetch any <code>Transition</code> elements.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#greedy-execution","title":"Greedy Execution","text":"<p>Greedy rules are executed for all instances of the input type (including sub-types). The difference between a regular rule and a greedy rule, is that a regular rule only applies to instances of the given input type and not the sub-types. Note that greedy rules are not specially prioritized during execution.</p> <pre><code>//@greedy tag allows the rule to be applicable to input type and all sub-types\n@greedy\nrule NamedElement2Heading\n    transform e : Source!NamedElement\n    to h1 : Target!H1 {\n\n    h1.value = e.name;\n}\n</code></pre> <p>In the example above, the <code>NamedElement2Heading</code> rule is greedy (annotated using <code>@greedy</code> tag) and is executed for all instances of the <code>NamedElement</code> type (including sub-types). Every flowchart element inherits from the <code>NamedElement</code> meaning the rule applies to all elements in the source model. Thus, names of all flowchart elements are transformed into headings.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#primary-annotation","title":"Primary Annotation","text":"<p>Primary annotated rules are used to order the results of an equivalents() operation (defined in some other rule). The results of primary rules precede other rules. In the following example, the <code>Transition2Heading</code> rule is primary and its results precede other rules.</p> <pre><code>rule Flowchart2Heading\n    transform f : Source!Flowchart\n    to contents : Target!DIV {\n\n    // Produce a DIV containing only the headings of the transitions\n    // and not containing the links\n    for (t in f.transitions) {\n        contents.children.add(t.equivalents().first);\n    }\n}\n\nrule Transition2SourceLink\n    transform t : Source!Transition\n    to a : Target!A {\n\n    a.value = t.source.name;\n    a.ahref = \"#\" + t.source.name;\n}\n\nrule Transition2TargetLink\n    transform t : Source!Transition\n    to a : Target!A {\n\n    a.value = t.name;\n    a.ahref = \"#\" + t.target.name;\n}\n\n//Results of equivalents() can be ordered using rules that are declared @primary\n//Primary rule's results precede other rules\n@primary\nrule Transition2Heading \n    transform t : Source!Transition\n    to h1 : Target!H1 {\n\n    h1.value = t.name;\n}\n</code></pre> <p>This ETL definition shows that the <code>Flowchart2Heading</code> rule transforms a flowchart element into a <code>DIV</code> block. All transitions of the flowchart source model are fetched and added to the <code>contents</code> DIV block. When <code>equivalents()</code> operation is performed, all results of transformed <code>Transition</code> elements from other rules are returned. However, the rule annotated as <code>@primary</code> can supersede other rules in the result list and its result will be passed to the method call. In this case, the <code>Transition2Heading</code> rule is primary and its result will be passed to the <code>contents</code> DIV block. The other two rules (<code>Transition2SourceLink</code> and <code>Transition2TargetLink</code>) are not primary and their results will be ignored, they will still be executed but their results will not be in the <code>DIV</code> block. Note that <code>equivalents()</code> returns a sequence and <code>equivalents().first</code> returns the first item of the sequence not the results list.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#equivalent-operation","title":"Equivalent Operation","text":"<p>Equivalent operation is mainly used for resolving the source elements and defining the mapping between input and output objects. When equivalents() operation is applied on a single source element, it would establish the transformation trace, invoke other rules (using the same source element) and return the newly transformed target elements. However, when equivalent() operation is applied, only the first result of the equivalents() operation is returned. When equivalent() operation is used on a collection, it returns a flattened collection instead of keeping more dimensions. In the example below, the <code>Flowchart2Div</code> rule transforms a <code>Flowchart</code> element into a <code>DIV</code> element. The <code>Transition2Heading</code> rule transforms a <code>Transition</code> element into an <code>H1</code> element. The <code>Flowchart2Div</code> rule uses the <code>equivalent()</code> operation to resolve the <code>Transition</code> elements of the <code>Flowchart</code> element.</p> <pre><code>//This rule is used to transform a Flowchart into a DIV\nrule Flowchart2Div\n    transform f : Source!Flowchart\n    to div : Target!DIV {\n\n    //The \"::=\" operator is the same as equivalent() method.\n    //This equivalent() method returns a flattened list of all the transitions.\n    div.children ::= f.transitions; \n\n    // The preceeding line is the same as:\n    //   div.children.addAll(f.transitions.equivalent());\n    //\n    // And also the same as:\n    //   for (t in f.transitions) {\n    //     div.children.add(t.equivalent());\n    //   }\n}\n\n//This rule is used to transform a Transition into a Heading.\nrule Transition2Heading\n    transform t : Source!Transition\n    to h1 : Target!H1 {\n\n    h1.value = t.name;\n}\n</code></pre> <p>ETL uses a special EOL operator (<code>::=</code>) to replace <code>equivalent()</code> clause as it keeps the code more concise and readable. The <code>Flowchart2DIV</code> rule contains an output element <code>div</code> of the <code>DIV</code> type. <code>div</code> adds all the <code>Transition</code> elements of the <code>Flowchart</code> element using the <code>equivalent()</code> operation. Remember, <code>equivalent()</code> returns only the first result of the <code>equivalents()</code> operation. In this case, the <code>Transition2Heading</code> rule is executed and the <code>h1</code> element is returned for each of the transitions. The <code>h1</code> elements are then added to the <code>div</code> element. If there was another rule that transformed <code>Transition</code> elements, then the order of the rules would determine which rule's result is returned by the <code>equivalent()</code> operation.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#multiple-targets","title":"Multiple Targets","text":"<p>As the name suggests, in ETL the user can have one source element transforming to multiple target elements in one rule. All target elements are mapped to the same source element and can interact with other target elements of the rule. In the example below, the <code>Action2Elements</code> rule transforms an <code>Action</code> element into a <code>DIV</code>, <code>H1</code>, and <code>A</code> element. The <code>Decision2Elements</code> rule transforms a <code>Decision</code> element into a <code>DIV</code>, <code>H1</code>, and a sequence of <code>A</code> elements.</p> <pre><code>rule Action2Elements\n    transform a : Source!Action\n    to container : Target!DIV, title : Target!H1, link : Target!A { \n    //Note only one source element is transformed into 3 targets\n\n    //\"Get up\" is not transformed as it has no outgoing transitions\n    guard: a.outgoing.notEmpty() \n\n    title.value = a.name;\n    link.value = \"Next steps\";\n    link.ahref = a.outgoing.first.target.name;\n\n    container.children.add(title);\n    container.children.add(link);\n}\n\nrule Decision2Elements\n    transform d : Source!Decision\n    to container : Target!DIV, title : Target!H1, links : Sequence(Target!A) {\n\n    title.value = d.name;\n\n    for (t in d.outgoing) {\n        var link = new Target!A;\n        link.value = t.target.name;\n        link.ahref = t.target.name;\n        links.add(link);\n    }\n\n    container.children.add(title);\n    container.children.addAll(links);\n}\n</code></pre> <p>In the first rule <code>Action2Elements</code>, each of the <code>Action</code> flowchart elements is transformed into a <code>DIV</code> block, <code>H1</code> heading and <code>A</code> reference link. All of the target elements resolve to the same source element <code>a</code>. The <code>guard</code> clause ensures that only <code>Action</code> elements with outgoing transitions are transformed. Additionally, all target elements can interact with each other in the EOL statments i.e. <code>container</code> DIV element adds <code>title</code> and <code>link</code> elements as its children. </p> <p>The second rule <code>Decision2Elements</code> transforms each of the <code>Decision</code> flowchart elements into a <code>DIV</code> block, <code>H1</code> heading and a sequence of <code>A</code> reference links. The <code>links</code> sequence is used to store all the <code>A</code> elements. The <code>for</code> loop iterates over all outgoing transitions of the <code>Decision</code> element and adds a new <code>A</code> element to the <code>links</code> sequence. The <code>links</code> sequence and <code>title</code> output variables are then added to the <code>container</code> DIV element.</p>"},{"location":"tutorials/etl-flowchart-to-html.html#development-platforms","title":"Development Platforms","text":"<p>Currently, the Flowchart to HTML project is available on the online Epsilon playground, where you can interact with all of the transformation examples documented above. </p>"},{"location":"tutorials/linked-list-reversal-etl.html","title":"Linked List Reversal - ETL Implementation","text":""},{"location":"tutorials/linked-list-reversal-etl.html#etl-transformation","title":"ETL Transformation","text":"<p>To demonstrate the ETL capabilities, let's look at a simple example that reverses a linked list using ETL. A linked list with 2 nodes (N1 and N2) is reversed through model transformation.</p> <p>Source Model</p> <p> </p> Linked list BEFORE transformation <p>Target Model</p> <p> </p> Linked list AFTER transformation <p></p>"},{"location":"tutorials/linked-list-reversal-etl.html#etl-definition","title":"ETL Definition","text":"<p>There are 2 aspects of the linked list which are changed from the source model to the target model (thus requiring two rules): </p> <ol> <li>The head of the linked list is swapped with its tail. </li> <li>The nodes are reversed i.e. pointing to the previous node instead of the next one.</li> </ol> <p>First, the linked list's head is reversed:</p> <pre><code>rule LinkedList2LinkedList \n    transform s : Source!LinkedList\n    to t : Target!LinkedList {\n\n    t.nodes ::= s.nodes;\n    t.head ::= Source!Node.all.selectOne(n|n.next == null);\n}\n</code></pre> <p>Let's have a look at each line of code to understand ETL logic and semantics:</p> <p>In line 1, <code>rule</code> declares a transformation rule with a unique name 'LinkedList2LinkedList'.   In line 2, <code>transform</code> keyword indicates the source parameter we want to transform in this rule. Thus, a source parameter name 's' and a source parameter type 'Source!LinkedList' (the source metamodel's LinkedList class is being referenced here).   In line 3, similar to the previous line's format, <code>to</code> keyword is followed by the target parameter name 't' and target parameter type 'Target!LinkedList'. The target element properties are being configured here. The open curly brace ({) indicates the start of the rule's <code>body</code>. In line 5, the target element's nodes are assigned using the EOL SpecialAssignment operator (::=) to be the equivalent of the source element's nodes. Please note that ::= is the same as an <code>equivalent()</code> operation.  In line 6, the target element's head <code>t.head</code> is assigned the equivalent value of a node from the source model that points to <code>null</code> i.e. it is the last node. In line 7, the close curly brace (}) indicates the end of the <code>body</code> and the dedent means the end of the transformation rule.</p> <p>Second, the nodes are reversed:</p> <pre><code>rule Node2Node\n    transform s : Source!Node\n    to t : Target!Node {\n\n    t.name = s.name;\n    t.next ::= Source!Node.all.selectOne(n|n.next = s);\n}\n</code></pre> <p>In this rule, the source and target parameter types are also the same. Remember, the linked list is only meant to be reversed hence the structural properties of the linked list remain unchanged. In the <code>transform</code> statement, a source parameter 's' of the type 'Source!Node' (Node class in the source metamodel) is transformed <code>to</code> the target parameter 't' of the type 'Target!Node' (same Node class definition as in the source metamodel). The target element is assigned the same name as the source element. SpecialAssignment operator (::=) is not used here because <code>name</code> is a string attribute of a <code>Node</code> class and not a reference. The target element's <code>next</code> property is assigned the equivalent value of a node from the source model whos <code>next</code> value is the source node element 's'.</p> <p>The example project also includes other important files: Source model (.xmi), Source metamodel (.emf) and a Target metamodel (.emf) which are listed below.</p>"},{"location":"tutorials/linked-list-reversal-etl.html#source-and-target-metamodel","title":"Source and Target Metamodel","text":"<pre><code>@namespace(uri=\"linkedlist\", prefix=\"\")\npackage linkedlist;\n\nclass LinkedList {\n    ref Node head;\n    val Node[*] nodes;\n}\n\nclass Node {\n    attr String name;\n    ref Node next;\n}\n</code></pre> <p>Note: Usually source and target metamodels may not be the same. In this linked list reversal example, the data structure did not need to be changed but the property values.</p>"},{"location":"tutorials/linked-list-reversal-etl.html#source-model","title":"Source Model","text":"<pre><code>&lt;?nsuri linkedlist?&gt;\n&lt;linkedlist head=\"N1\"&gt;\n    &lt;node label=\"N1\" next=\"N2\"/&gt;\n    &lt;node label=\"N2\"/&gt;\n&lt;/linkedlist&gt;\n</code></pre>"},{"location":"tutorials/linked-list-reversal-etl.html#target-model","title":"Target Model","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"ASCII\"?&gt;\n&lt;LinkedList\n  xmi:version=\"2.0\"\n  xmlns:xmi=\"http://www.omg.org/XMI\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns=\"linkedlist\"\n  xsi:schemaLocation=\"linkedlist target.emf\"\n  head=\"//@nodes.1\"&gt;\n  &lt;nodes name=\"N1\" /&gt;\n  &lt;nodes name=\"N2\" next=\"//@nodes.0\" /&gt;\n&lt;/LinkedList&gt;\n</code></pre>"},{"location":"tutorials/linked-list-reversal-etl.html#development-platforms","title":"Development Platforms","text":"<p>There are many ways to interact with ETL: an online Epsilon Playground, using Ant (Eclipse) or using Java. Try the linked list reversal example project using any of the three options.</p>"},{"location":"tutorials/linked-list-reversal-etl.html#online-playground","title":"Online playground","text":"<p>Try ETL online</p> <p>You can run and fiddle with an ETL transformation that transforms a linked list into its reverse version in the online Epsilon Playground.</p> <p></p>"},{"location":"tutorials/linked-list-reversal-etl.html#apache-ant-eclipse","title":"Apache Ant (Eclipse)","text":"<p>Click here to download the linked list example project or head over to the online Epsilon Playground and select <code>Download \u2192 Ant (Eclipse)</code> as shown below</p> <p></p> <p>Next step is to import the project in Eclipse. Once the ZIP file is downloaded, open your Eclipse IDE and do <code>File \u2192 Import \u2192 Existing Projects into Workspace \u2192 Select archive file \u2192 Finish</code>. </p> <p>Then, right click on <code>build.xml</code> and choose <code>Run as \u2192 Ant Build</code> to build the ETL project and generate the target model. Examine the generated model (target.xmi) to discover the linked list has been reversed! </p> <p></p>"},{"location":"tutorials/linked-list-reversal-etl.html#java-gradle","title":"Java (Gradle)","text":"<p>Download the linked list Java project.</p> <p>Unzip the project and import it into an IDE of your choice (e.g. Eclipse, IntelliJ, VSCode). Make sure the IDE uses JDK 17 or higher.</p> <p>Run <code>src/main/java/org/eclipse/epsilon/examples/Example.java</code> to generate <code>target.xmi</code> containing the target model. The target model is the reversed linked list.</p> <p>To run <code>Example.java</code> in VSCode, make sure the Gradle extension is enabled and click on the Gradle icon in the sidebar then do <code>playground-example \u2192 Tasks \u2192 application \u2192 run</code>.</p>"},{"location":"tutorials/linked-list-reversal-etl.html#references","title":"References","text":"<ul> <li>ETL Syntax</li> <li>EOL Syntax</li> </ul>"},{"location":"tutorials/linked-list-reversal-yamtl.html","title":"Linked List Reversal - YAMTL Implementation","text":"<p>To demonstrate the YAMTL capabilities, let's look at a simple example that reverses a linked list using YAMTL. A linked list with 2 nodes (N1 and N2) is reversed through model transformation.</p> <p>Source Model</p> <p> </p> Linked list BEFORE transformation <p>Target Model</p> <p> </p> Linked list AFTER transformation <p></p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#yamtl-transformation","title":"YAMTL Transformation","text":"<p>There are 2 aspects of the linked list which are changed from the source model to the target model (thus requiring two tranformation rules): </p> <ol> <li>The head of the linked list is swapped with its tail. </li> <li>The nodes are reversed i.e. pointing to the previous node instead of the next one.</li> </ol>"},{"location":"tutorials/linked-list-reversal-yamtl.html#yamtl-definition","title":"YAMTL Definition","text":"<p>The YAMTL definition is in a Groovy script as follows: </p> Snippet from ReverseLinkedList.groovy<pre><code>class ReverseLinkedList extends YAMTLModule {\n    public ReverseLinkedList(EPackage llPk) {\n        YAMTLGroovyExtensions_dynamicEMF.init(this)\n        header().in('in', llPk).out('out', llPk)\n\n        ruleStore([\n            rule('LinkedList2LinkedList')\n                .in('s', llPk.LinkedList)\n                .out('t', llPk.LinkedList, {\n                    t.nodes = fetch(s.nodes) //Mapping\n                    t.head = fetch(allInstances(llPk.Node).find{it.next==null})\n                }),\n\n            rule('Node2Node')\n                .in('s', llPk.Node)\n                .out('t', llPk.Node, {\n                    t.name = s.name\n                    t.next = fetch(allInstances(llPk.Node).find{it.next==s})\n                })\n        ])\n    }\n}\n</code></pre> <p>Let's understand each line of code to learn the YAMTL syntax and semantics.</p> <p>In Line 1, the class (also name of the file) extends <code>YAMTLModule</code> (which is imported) to highlight the code block containing YAMTL definition. In Line 2, the public method has an argument <code>llPk</code> (referring to linked list package) of the type <code>EPackage</code>. This adds EMF extensions to interpret getters/setters of an EObject and reference to classifiers inside an EPackage. Now, the classes in the <code>.emf</code> file can be accessed. In Line 3, the YAMTL Groovy Extensions for EMF import is initialised. In Line 4, the in and out parameters (of the source and target models respectively) for the model transformation is defined. In Line 6, the list of transformation rules is initialised using <code>ruleStore</code> operation. Each rule is contained here, separated by commas (,). In Line 7-9, the first rule <code>LinkedList2LinkedList</code> is created with the input source element 's' of the <code>Node</code> type accessed from the <code>llPk</code> package. The corresponding target element 't' is of the data type <code>Node</code> and the <code>out</code> operation also contains execution statements written in curly braces <code>{}</code>. In Line 10, nodes of the <code>LinkedList</code> 's' are all fetched and assigned to the target <code>LinkedList</code> element 't'. Here, the references or mappings of the nodes are passed to the target element. In Line 11, all <code>llPk.node</code>s are queried to find a <code>Node</code> object that does not reference or point to another <code>Node</code> object i.e. it points to <code>null</code>. The result of the <code>fetch</code> operation is assigned as the <code>head</code> attribute of the target element. Remember, this is one of the aspects discussed above, the head of the linked list is swapped with its tail. In Line 14-16, a new rule <code>Node2Node</code> is defined, its source element 's' and target element 't' have been initialised. Both elements are of the same type <code>Node</code> accessed via the <code>llPk</code> package. In Line 17, the source element's <code>name</code> attribute is assigned to the target element's <code>name</code> field. In Line 18, all <code>Node</code> objects in the source model are queried to find a <code>Node</code> object that has a <code>name</code> attribute which points/references to the source element 's'. The resultant <code>Node</code> object is fetched and assigned to the target element's <code>next</code> attribute. Recall, the second transformation aspect previously discussed, each node points to the previous node instead of the next one.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#transformation-test-script","title":"Transformation Test Script","text":"<p>Besides the actual transformation definition, you will also need a Groovy test script that automates the entire transformation process. Here, the relevant project files are configured and test assertions are implemented. Check out a snippet from the test script for the linked list reversal example below:</p> Snippet from ReverseLinkedListTest.groovy<pre><code>// model transformation execution example\ndef metamodel = YAMTLModule.loadMetamodel(BASE_PATH + '/LinkedList.ecore') as EPackage\ndef xform = new ReverseLinkedList(metamodel)\nxform.loadInputModels(['in': BASE_PATH + '/inputList.xmi'])\nxform.execute()\nxform.saveOutputModels(['out': BASE_PATH + '/outputList.xmi'])\n</code></pre> <p>The transformation is executed through a Gradle build run which also runs this test script. In the code snippet above, a groovy method contains the code for model transformation execution and tests assertion. First, the <code>metamodel</code> is loaded from a <code>.ecore</code> file as an <code>EPackage</code>. Then, <code>xform</code> initialises a new <code>ReverseLinkedList</code> transformation definition and passes the metamodel as an <code>EPackage</code> (<code>llPk</code> was a reference to the metamodel). The input parameter within the YAMTL definition script is set to be the relative location to the <code>inputList.xmi</code> file which contains the source model. This source model is loaded into the model transformation, the transformation rules are executed and the output model returned from <code>ReverseLinkedList()</code> is saved at a defined location through the output parameter. After the transformation is completed, some tests can be run to check the contents of the generated target model. The output model is compared against an expected output <code>expectedOutput.xmi</code> using <code>EMFComparator</code>.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#source-and-target-metamodel","title":"Source and Target Metamodel","text":"LinkedList.emf<pre><code>@namespace(uri=\"linkedlist\", prefix=\"\")\npackage linkedlist;\n\nclass LinkedList {\n    ref Node head;\n    val Node[*] nodes;\n}\n\nclass Node {\n    attr String name;\n    ref Node next;\n}\n</code></pre> <p>The Emfatic textual syntax is used to define the metamodel. The corresponding ECore file \"LinkedList.ecore\" can then be generated if the Emfatic software package is installed.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#source-model","title":"Source Model","text":"<p>Graphical Concrete Syntax</p> <p> </p> Linked list BEFORE transformation <p>XMI serialization of the Abstract Syntax inputList.xmi<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;LinkedList\n    xmi:version=\"2.0\"\n    xmlns:xmi=\"http://www.omg.org/XMI\"\n    xmlns=\"linkedlist\"\n    head=\"//@nodes.0\"&gt;\n    &lt;nodes name=\"N1\"\n        next=\"//@nodes.1\" /&gt;\n    &lt;nodes name=\"N2\" /&gt;\n&lt;/LinkedList&gt;\n</code></pre></p> <p>The source model conforms to the source metamodel (<code>LinkedList.emf</code>). The Groovy test script loads the source model, applies the transformation and saves the target model generated.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#target-model","title":"Target Model","text":"<p>Graphical Concrete Syntax</p> <p> </p> Linked list AFTER transformation <p>XMI serialization of the Abstract Syntax outputList.xmi<pre><code>&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;LinkedList\n  xmi:version=\"2.0\"\n  xmlns:xmi=\"http://www.omg.org/XMI\"\n  xmlns=\"linkedlist\"\n  head=\"//@nodes.1\"&gt;\n  &lt;nodes name=\"N1\" /&gt;\n  &lt;nodes name=\"N2\" next=\"//@nodes.0\" /&gt;\n&lt;/LinkedList&gt;\n</code></pre></p> <p>This is the output file you should expect when you correctly run the YAMTL program.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#development-platforms","title":"Development Platforms","text":"<p>Download the linked list reversal project (ZIP file). You can unzip and import the project into an IDE of your choice. This documentation will provide details on how to setup the example project on Eclipse, IntelliJ and VSCode.</p> <p>YAMTL uses groovy scripts to define the models and transformations so generally any IDE will need some Groovy support through extensions/plug-ins. Make sure to have YAMTL correctly configured or do the necessary steps found in the YAMTL Workspace Configuration section before you run the project.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#eclipse","title":"Eclipse","text":"<p>Unzip the downloaded project. In Eclipse, click on <code>File \u2192 Import \u2192 Existing Projects into Workspace \u2192 Select root directory \u2192 Finish</code>. This will import and load the project in the IDE.</p> <p>Right click on <code>src/test/groovy/linkedListReversal/ReverseLinkedListTest.groovy</code> then <code>Run as \u2192 JUnit Test</code>. Once the test is completed, a new <code>outputList.xmi</code> will be generated in the <code>model</code> directory. Examine this file and notice if the linked list has been reversed.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#intellij","title":"IntelliJ","text":"<p>Within IntelliJ, go to <code>File \u2192 Open</code> and open the project.</p> <p>Right click on <code>src/test/groovy/linkedListReversal</code> folder then 'Run Tests...'. </p> <p>Alternatively, click on the green run button in the top bar to run <code>Tests in 'yamtl-linkedlistreversal'</code> which builds the project and generates an <code>outputList.xmi</code> in the <code>model</code> directory. </p> <p>Examine this file and notice if the linked list has been reversed.</p> <p></p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#vscode","title":"VSCode","text":"<p>In VSCode, import the project by doing <code>File \u2192 Open</code>.</p> <p>After you have imported the example project into the workspace, click on the Gradle icon in the left sidebar. Then perform <code>Tasks \u2192  build \u2192 clean</code>. Do <code>Tasks \u2192 build \u2192 build</code> to build the entire Gradle project (it also runs the <code>ReverseLinkedListTest.groovy</code> file). </p> <p></p> <p>Once the project is successfully built, an <code>outputList.xmi</code> will be generated in the <code>model</code> directory. Examine this file and notice if the linked list has been reversed.</p>"},{"location":"tutorials/linked-list-reversal-yamtl.html#references","title":"References","text":"<ul> <li>YAMTL Syntax</li> <li>YAMTL Incremental Support</li> <li>YAMTL Original Documentation</li> </ul>"},{"location":"tutorials/yamtl-flowchart-to-html.html","title":"Flowchart to HTML - YAMTL Implementation","text":"<p>In this tutorial, the core concepts of YAMTL transformations will be described. To do this, elements of a flowchart model will be transformed using special operations into valid HTML elements.</p> <p><pre><code>graph LR\n  A[Begin] --&gt;|Start| B[Wake up];\n  B --&gt; C{Is it really too early?};\n  C --&gt; |Yes| D[Sleep];\n  C --&gt; |No| E[Get up]\n  D --&gt; |Some Time Passes| B;</code></pre> </p> Wakeup Flowchart <p>The flowchart model (abstract representation shown in the figure above) has different types of elements: Node, Action, Decision, Transition, and Subflow.</p> <p>Node elements are the most basic elements in a flowchart. They can have any number of incoming and outgoing transitions.</p> <p>Action elements are a type of Node element. They have a value describing an action and such elements can also have any number of incoming and outgoing transitions.</p> <p>Decision elements are another type of Node element. Its value indicates a decision (if-else condition) and a decision element can have any number of incoming and outgoing transitions.</p> <p>Transition elements are those arrows (direction flow) in the flowchart figure above. They have a name attribute. A transition element must have one source Node (start of the arrow) and one target Node (end of the arrow).</p> <p>Subflow is a special Node element that contains a flowchart inside a flowchart (making it a sub-section). A subflow element has a name and all the features of a flowchart i.e. can have any number of nodes and transitions.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#source-metamodel","title":"Source Metamodel","text":"<p>This is the flowchart metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#target-metamodel","title":"Target Metamodel","text":"<p>This is the HTML metamodel in Emfatic <code>.emf</code> as defined in the Flowchart to HTML case before.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#source-model","title":"Source Model","text":""},{"location":"tutorials/yamtl-flowchart-to-html.html#wakeup-flowchart","title":"Wakeup Flowchart","text":"<p>Let's turn that flowchart into an XMI representation because that is the required format for source models in YAMTL (note that this is equivalent to the Flexmi code shown on the previous page):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"tutorials/yamtl-flowchart-to-html.html#wakeup-flowchart-with-subflow","title":"Wakeup Flowchart with Subflow","text":"<p>Some MTL examples also transform the Flowchart's subflow elements, so, another flowchart (that contains subflow) based on the original flowchart is also defined. The flowchart model with subflow is as follows:</p> <p>Graphical Representation</p> <p></p> <p>Abstract Syntax in XMI</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;flowchart:Flowchart xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:flowchart=\"flowchart\" xmi:id=\"_9mLMwDY6EeOwt8pm-kjW_Q\" name=\"Wakeup\"&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwTY6EeOwt8pm-kjW_Q\" name=\"Wake up\" outgoing=\"_9mLMxjY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMyDY6EeOwt8pm-kjW_Q _9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxDY6EeOwt8pm-kjW_Q\" name=\"Get up\" incoming=\"_9mLz0DY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMxTY6EeOwt8pm-kjW_Q\" name=\"begin\" outgoing=\"_9mLz0TY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;nodes xsi:type=\"flowchart:Subflow\" xmi:id=\"_BYIhADZzEeOvH6AlutIRRw\" name=\"Snoozing\"&gt;\n    &lt;nodes xsi:type=\"flowchart:Action\" xmi:id=\"_9mLMwzY6EeOwt8pm-kjW_Q\" name=\"Sleep\" outgoing=\"_9mLMyDY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxzY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;nodes xsi:type=\"flowchart:Decision\" xmi:id=\"_9mLMwjY6EeOwt8pm-kjW_Q\" name=\"Is it really too early?\" outgoing=\"_9mLMxzY6EeOwt8pm-kjW_Q _9mLz0DY6EeOwt8pm-kjW_Q\" incoming=\"_9mLMxjY6EeOwt8pm-kjW_Q\"/&gt;\n    &lt;transitions xmi:id=\"_9mLMxzY6EeOwt8pm-kjW_Q\" name=\"Yes\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMwzY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;/nodes&gt;\n  &lt;transitions xmi:id=\"_9mLMxjY6EeOwt8pm-kjW_Q\" name=\"\" source=\"_9mLMwTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwjY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLMyDY6EeOwt8pm-kjW_Q\" name=\"Some Time Passes\" source=\"_9mLMwzY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0DY6EeOwt8pm-kjW_Q\" name=\"No\" source=\"_9mLMwjY6EeOwt8pm-kjW_Q\" target=\"_9mLMxDY6EeOwt8pm-kjW_Q\"/&gt;\n  &lt;transitions xmi:id=\"_9mLz0TY6EeOwt8pm-kjW_Q\" name=\"start\" source=\"_9mLMxTY6EeOwt8pm-kjW_Q\" target=\"_9mLMwTY6EeOwt8pm-kjW_Q\"/&gt;\n&lt;/flowchart:Flowchart&gt;\n</code></pre>"},{"location":"tutorials/yamtl-flowchart-to-html.html#transformation-examples","title":"Transformation Examples","text":""},{"location":"tutorials/yamtl-flowchart-to-html.html#basic-example","title":"Basic Example","text":"<p>This is a simple example that converts all flowchart elements into HTML <code>H1</code> headings:</p> <pre><code>ruleStore([\nrule('Flowchart2Heading')\n.in(\"f\", flowchartPk.Flowchart)\n.out(\"h1\", htmlPk.H1, {\nh1.value = f.name\n}),\nrule('Action2Heading')\n.in(\"a\", flowchartPk.Action)\n.out(\"h1\", htmlPk.H1, {\nh1.value = a.name\n}),\nrule('Decision2Heading')\n.in(\"d\", flowchartPk.Decision)\n.out(\"h1\", htmlPk.H1, {\nh1.value = d.name\n}),\nrule('Transition2Heading')\n.in(\"t\", flowchartPk.Transition)\n.out(\"h1\", htmlPk.H1, {\nh1.value = t.name\n})\n])\n</code></pre> <p>In this code snippet, 4 rules transform different flowchart objects: Flowchart, Action, Decision, and Transition; into H1 elements. Each rule has a name (within <code>rule('&lt;ruleName&gt;')</code> clause), an input element (with a name and type), and an output element (with a name, type and a lamda expression). The lambda expression of all rules follow the same format: assign the name of the input object to the value of the heading <code>H1</code>.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#rule-inheritance","title":"Rule Inheritance","text":"<p>First, an abstract rule is defined with a set of input and output elements. Then, a child rule is declared which inherits from the abstract rule (parent) and performs the transformation. YAMTL also supports multiple rule inheritance where a child rule can inherit from multiple parent rules.</p> <pre><code>ruleStore([\n// This parent rule is abstract, so it will not be applied directly\n// but it can be executed by its children\nrule('Flowchart2H1')\n.isAbstract()\n.in(\"e\", flowchartPk.Flowchart)\n.out(\"h1\", htmlPk.H1, {\nh1.value = \"Flowchart \" + e.name\n}),\n// This child rule inherits from the previous one\nrule('Subflow2H1')\n.inheritsFrom(['Flowchart2H1'])\n.in(\"e\", flowchartPk.Subflow)\n.out(\"h1\", htmlPk.H1, {\n// R.H.S. h1.value is inherited from the parent rule\n// 'e' object is passed to the parent rule to calculate h1.value\nh1.value = \"Subflow \" + h1.value\n})\n])\n</code></pre> <p><code>isAbstract()</code> clause is used to define an abstract rule. The abstract rule contains an input element of type <code>Flowchart</code> and an output element of H1 heading. The output object's value is updated to the input object's name with a prefix \"Flowchart\". A new child rule that inherits from the abstract rule using the <code>inheritsFrom(['&lt;ruleNameList&gt;'])</code> clause. The child rule <code>Subflow2H1</code> has an input element of type <code>Subflow</code> which extends <code>Flowchart</code>. Its name is <code>e</code> just like in the parent rule, meaning when the child rule is executed the input object <code>e</code>  overrides the object <code>e</code> in the parent rule. The output element's type must be the same as the parent rule. The output object's value is \"Subflow \" followed by the value of <code>h1</code> in the abstract rule because both rules are executed and the output objects are calculated. Thus, the final output is an H1 element of the following format:</p> <pre><code>&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"tutorials/yamtl-flowchart-to-html.html#rule-override","title":"Rule Override","text":"<p>There may be cases where you need to override the output object of the parent rule. This means that when the rule that inherits is executed, the value of the output object in the parent rule is overridden by the value of the output object calculated in the child rule. This also means that the child output object has no value at the start of execution unlike when it is inherited with no override.</p> <pre><code>ruleStore([\nrule('Flowchart2H1')\n.in(\"e\", flowchartPk.Flowchart)\n.out(\"h1\", htmlPk.H1, {\n//Assigns the name of the flowchart to the value of the h1 element\nh1.value = \"Flowchart \" + e.name }),\nrule('Subflow2H1')\n.inheritsFrom(['Flowchart2H1'])\n.in(\"e\", flowchartPk.Subflow)\n.out(\"h1\", htmlPk.H1, {\n//If h1 value is inherited then it is not null, else it is null\nif(h1.value !== null) {\n//R.H.S h1.value is already calculated and inherited\nh1.value = \"Subflow \" + h1.value\n} else {\n//h1 is newly initialised since rule is overridden\nh1.value = \"Subflow \" + e.name //Overridden output object\n}\n//Override the parent rule so the child rule's h1 object is used    \n}).overriding()\n//Try out the above transformation without the overriding() method\n//and see the difference in inheritance behaviour   \n])\n</code></pre> <p>To better understand the properties of the <code>overriding()</code> clause, you should see the difference in execution and output, when you use override and when you do not.</p> <p>When you use <code>overrding()</code>:</p> <p>The rule that inherits (<code>Subflow2H1</code>), overrides the parent rule's (<code>Flowchart2H1</code>) output object <code>h1</code> meaning its value is newly initialized (<code>null</code>), thus, the else-condition is invoked. The local input object <code>e</code> is referenced within the output block and its name (<code>e.name</code>) is retrieved to be assigned as part of a string to the value of <code>h1</code>. The output of this transformation would look like this:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Snoozing\"/&gt;\n</code></pre> <p>When you do not use <code>overriding()</code>:</p> <p>When the child rule is executed, the output element(s) of the parent rule is calculated first. This means that <code>h1</code> output object has a computed value in the parent rule. When you access the <code>h1</code> output object in the child rule, it references to the parent rule's <code>h1</code> output object (which contains a value). Thus, the if-condition is satisfied and the child rule's output object <code>h1</code> is assigned the value of a string and the value of <code>h1</code> object calculated within the parent rule. The main output of this transformation would be:</p> <pre><code>&lt;H1 value=\"Flowchart Wakeup\"/&gt;\n&lt;H1 value=\"Subflow Flowchart Snoozing\"/&gt;\n</code></pre>"},{"location":"tutorials/yamtl-flowchart-to-html.html#lazy-rules","title":"Lazy Rules","text":"<p>A lazy rule is a rule that is executed after all non-lazy rules. When multiple lazy rules are defined, then the lazy rules are invoked in sequential order.</p> <pre><code>ruleStore([\nrule('Flowchart2Heading')\n.in('f', flowchartPk.Flowchart)\n.out('div', htmlPk.DIV, {\n// without LAZY: div.children.addAll(fetch(f.nodes))\n// with LAZY rules\ndiv.children.addAll(fetch(f.nodes, 'out', 'NodeRule'))\n}),\nrule('NodeRule')\n.isUniqueLazy()\n.in(\"in\", flowchartPk.Node)\n.out(\"out\", htmlPk.H1, {\nout.value = in.name\n}),\nrule('Transition2H1')\n.in(\"t\", flowchartPk.Transition)\n.out(\"h1\", flowchartPk.H1, {\nh1.value = t.name\n})\n])\n</code></pre> <p>A <code>lazy</code> rule is called and not scheduled by the YAMTL engine, which may lead to different results each time the rule is executed. A <code>uniqueLazy</code> rule always outputs the same result no matter how many times it is invoked and executed. In the code snippet above, <code>Flowchart2Heading</code> rule adds some nodes to a <code>div</code> HTML block. The <code>div</code> adds children from another rule using a special <code>fetch</code> operation: <code>fetch(inputMatchedObject, outVarName, ruleName)</code>, where <code>inputMatchedObject</code> can be just a single value or a collection; <code>outVarName</code> is the name of the output object of the other rule which is being accessed; <code>ruleName</code> is the name of that other rule. In this example, <code>inputMatchedObject</code> is <code>f.nodes</code> which is a collection of <code>Node</code> objects found in the output object of the matched <code>NodeRule</code>. Since <code>NodeRule</code> has not been executed, the values of <code>div</code> are not populated just yet. Next, <code>NodeRule</code> is tagged as <code>uniqueLazy</code> so it is not executed and is skipped for now. <code>Transition2H1</code> rule transforms all <code>Transition</code> elements into <code>H1</code> headings, where the value of an <code>H1</code> element is the the name of the <code>Transition</code> passed to the input pattern. Now all non-lazy rules have been invoked so the <code>uniqueLazy</code> rule (<code>NodeRule</code>) can be executed next. All <code>Node</code> objects are transformed into <code>H1</code> HTML elements, where each <code>H1</code> output object's value is the name of the <code>Node</code> object it has been transformed from. This rule generates a collection of <code>H1</code> headings which can finally be passed to the special <code>fetch</code> operation of <code>Flowchart2Heading</code> rule. Thus, the <code>div</code> output object contains a collection of <code>H1</code> elements with names of <code>Node</code> objects as their values.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#transient-rules","title":"Transient Rules","text":"<p>Transient rules are rules whose output is not persisted in the target model. They are used to perform calculations and update objects in the target model. The transient clause is used to define a transient rule.</p> <pre><code>// an attribute shared among rules\ndef count = 0\nruleStore([\nrule('Transitions2Div')\n.isTransient()\n.in(\"t\", flowchartPk.Transition)\n.out(\"div\", htmlPk.DIV, {\ncount++\nprintln(count)\n}),         rule('FlowChart')\n.in(\"f\", flowchartPk.Flowchart)\n.out(\"h1\", htmlPk.H1, {\nh1.value = \"The ${f.name} flowchart has ${count} transitions\"\n.toString()\n})\n])\n])\n</code></pre> <p>In the above example, the <code>Transitions2Div</code> rule is declared as transient. The <code>out</code> block is used to update the <code>count</code> variable with the number of children in the <code>div</code> output object, which happens automatically due to the number of transition elements (inputs) that match the rule. The <code>FlowChart</code> rule is not transient and it has an input object of type <code>Flowchart</code> and an output object of type <code>H1</code>. The value of the <code>H1</code> output object is a string that contains the name of the flowchart and the value of the <code>count</code> variable.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#rule-filtering","title":"Rule Filtering","text":"<p>In this example, a filter condition (which is a lambda expression) is applied to a rule to transform selected input objects.</p> <pre><code>ruleStore([\nrule('SelectedTransitions2Text')\n.in(\"t\", flowchartPk.Transition)\n.filter{    //Filter input objects that satify this condition\nt.source.name == \"Is it really too early?\"      }\n.out(\"p\", htmlPk.P, {\np.value = t.name\n})\n])\n</code></pre> <p>The rule <code>SelectedTransitions2Text</code> has an input element as a <code>Transition</code> object. A filter condition is applied to check the name of the transition's source. If the transition source name is \"Is it really too early?\" then only those input <code>Transition</code> objects will be transformed. The output element is an HTML paragraph element <code>p</code> whose value is updated to the name of the input <code>Transition</code> object.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#derived-input-elements","title":"Derived Input Elements","text":"<p>Derived elements are derived from input elements that have been matched in preceding input patterns of a rule. Here, the matching process is manually described instead of the automatic matching in matched elements.</p> <pre><code>ruleStore([\nrule('Action2Heading')\n.in(\"a\", flowchartPk.Action)\n.in(\"b\", flowchartPk.Action).derivedWith{ def f = a.eContainer()\nf.nodes.first()\n}\n.out(\"h1\", htmlPk.H1, {\nh1.value = b.name\n})\n])\n</code></pre> <p>The rule <code>Action2Heading</code> contains an input object <code>b</code> that is derived from input object <code>a</code>'s first <code>Action</code> node. The output object <code>H1</code> is an HTML heading element with the value as the name of <code>b</code> input object. Note, that in the 'wakeup' flowchart model there are 4 <code>Action</code> elements so each of those is passed through the input patterns but since the <code>b</code> input object is derived from the first <code>Node</code> object of the <code>f</code> flowchart (<code>a</code>'s eContainer is the Flowchart object), the output will always be the name of the first node ('Wake up'). The result in the target model would look like this:</p> <pre><code>&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n&lt;H1 value=\"Wake up\"/&gt;\n</code></pre>"},{"location":"tutorials/yamtl-flowchart-to-html.html#multiple-sources","title":"Multiple Sources","text":"<p>If you want to transform multiple input objects into a single output object, you can do so by using the <code>in</code> clause multiple times. The input objects are matched in the order they are declared in the rule. Remember, the total number of input objects created is the cartesian product of the input objects of each input pattern. Usually, a filter is applied to the rule to ensure that the input objects are matched correctly and specifically chosen input objects are transformed.</p> <pre><code>ruleStore([\nrule('SelectedTransitions2Text')\n// This rule contains 3 input patterns\n// Multiple sources create a cartesian product of output elements\n// So filters are needed to avoid creating unwanted elements\n.in(\"a\", flowchartPk.Action)\n.filter {\n// Filter out those actions that do not have outgoing transitions\n!a.outgoing.isEmpty()\n}\n.in(\"d\", flowchartPk.Decision)\n.in(\"t\", flowchartPk.Transition)\n.filter{                        // Only transform actions that match the input transition name\n// OR\n// decision elements that contain the input transition name\na.outgoing.name[0] == t.name || d.outgoing.name.contains(t.name)\n}\n.out(\"p\", htmlPk.P, {\n// Create &lt;p&gt; elements with source, transition, and target info for action and decision elements\n// Multiple duplicates of the decision element will be created showcasing the cartesian product behaviour\nif(a.outgoing.name[0] == t.name) {\np.value = \"Source: ${a.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n} else if(d.outgoing.name[0] == t.name) {\np.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n} else if(d.outgoing.name[1] == t.name) {\np.value = \"Source: ${d.name}; Transition: ${t.name}; Target: ${t.target.name}\".toString()\n}\n})\n])\n</code></pre> <p>In the above example, the rule <code>SelectedTransitions2Text</code> has 3 input objects: <code>a</code> of type <code>Action</code>, <code>d</code> of type <code>Decision</code> and <code>t</code> of type <code>Transition</code>. A filter is applied to the rule to ensure that the input objects are matched correctly. The filter condition checks if the <code>Action</code> object has an outgoing transition and if the name of the first outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Action</code> object, the name of the <code>Transition</code> object and the name of the target of the <code>Transition</code> object. If the second condition (regarding equivalent names) is not satisfied, then the filter condition checks if the <code>Decision</code> object has an outgoing transition and if the name of the outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object. If the condition is not satisfied, then the filter condition checks if the <code>Decision</code> object has a second outgoing transition and if the name of the second outgoing transition is the same as the name of the <code>Transition</code> object. If the condition is satisfied, then the output object <code>p</code> is updated to a string that contains the name of the <code>Decision</code> object, the name of the <code>Transition</code> object, and the name of the target of the <code>Transition</code> object.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#mulitple-targets","title":"Mulitple Targets","text":"<p>If you want to transform a single input object into multiple output objects, you can do so by using the <code>out</code> clause multiple times. The output objects are created in the order they are declared in the rule.</p> <pre><code>ruleStore([\nrule('Action2Elements')\n// This rule has 1 input pattern and 3 output patterns\n// All output objects are mapped to the same input object\n.in(\"a\", flowchartPk.Action).filter { !a.outgoing.isEmpty() }\n.out(\"title\", htmlPk.H1, {\ntitle.value = a.name\n})\n.out(\"link\", htmlPk.A, {\nlink.value = \"Next steps\"\nlink.ahref = a.outgoing.first().target.name\n})\n.out(\"container\", htmlPk.DIV, {\n// output vars of the rule can be referred directly\ncontainer.children.add(title)\ncontainer.children.add(link)\n})\n])\n</code></pre> <p>In this scenario, there are 3 output objects: <code>title</code>, <code>link</code>, and <code>container</code>. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>a</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code> whose value is \"Next steps\" and the reference link is the name of the first outgoing transition's target. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The output of this transformation would look like this. The overall transformation converts <code>Action</code> elements into a <code>DIV</code> element that contains a <code>H1</code> element and an <code>A</code> element.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#to-many-operation","title":"To Many Operation","text":"<p>Matched rules can be declared with the modifier <code>toMany</code> that enables repeated rule application for the same input object subject to a valid termination condition <code>toManyCap</code> based on the match count. The argument passed to <code>toManyCap</code> is the number of output patterns in that rule. With <code>toMany</code> rules, the same rule may match the same object several times. In this case, we can refer to each (occurrence of a) match by the order in which they occurred: <code>fetch(inputMatchedObject, i)</code> will return the output object that was created by the <code>i</code>th match.</p> <p>When the output pattern consists of several object patterns, we need to specify the output object that we want to fetch: <code>fetch(inputMatchedObject, outVarName)</code> will return the output object corresponding to the output variable <code>outVarName</code>. If a matched rule with a complex output pattern is also declared as <code>toMany</code>, then we can retrieve the output object with the expression <code>fetch(inputMatchedObject, outVarName, i)</code>.</p> <pre><code>ruleStore([\nrule('Action2Elements')\n.toMany()\n.toManyCap({2})\n.in(\"d\", flowchartPk.Decision)\n.out(\"title\", htmlPk.H1, {\n// The value will differ every time the rule is re-applied\ntitle.value = d.name })\n.out(\"link\", htmlPk.A, {\n// Access the current number of rule application\n// using matchCount variable\nif (matchCount == 0) {\nlink.name = \"Transition link 1\"\nlink.value = fetch(d, \"title\", 0).value\nlink.ahref = d.outgoing[0].name\n} else {\nlink.name = \"Transition link 2\"\nlink.value = fetch(d, \"title\", 1).value\nlink.ahref =  d.outgoing[1].name\n}\n})\n.out(\"container\", htmlPk.DIV, { // Fetch the correct title and link for the current rule matching\ncontainer.value = \"Decision ${matchCount+1}\".toString()\ncontainer.children.add(fetch(d, \"title\", matchCount))\ncontainer.children.add(fetch(d, \"link\", matchCount))\n})\n])\n</code></pre> <p>The above excerpt contains just one rule <code>Action2Elements</code> with one input pattern and multiple output patterns. <code>toManyCap({2})</code> means that the same rule is applied twice. This is useful to execute when the rule is needed to be executed multiple times to get different output or to get the same output multiple times. The <code>title</code> output object is an HTML heading element <code>H1</code> whose value is the name of the input object <code>d</code>. The <code>link</code> output object is an HTML hyperlink element <code>A</code>. <code>matchCount</code> variable store the value of the current cycle of rule application, it is always between 0 and n (<code>toManyCap{n}</code>). In the first cycle of rule application, the <code>link</code> name, value (fetched from <code>title</code> object of the same cycle <code>0</code>) and the reference link (name of the first outgoing transition's name) is set. In the second cycle, we implement similar but different attributes to showcase the use of <code>matchCount</code>. The <code>container</code> output object is an HTML div element <code>DIV</code> that contains the <code>title</code> and <code>link</code> output objects as its children. The corresponding value of the <code>i</code>th iteration of the rule application must be applied (in the third argument of <code>fetch()</code>), which is best set as <code>matchCount</code> variable. This means that in each cycle of rule execution, the title and link elements generated in that cycle are added to the container.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#end-with-block","title":"End With Block","text":"<p>If you want elements of a rule to interact with each other, you can do so at the end of a rule execution using an optional operation called <code>endWith</code>. An <code>endWith</code> block allows the user to group all elements of a rule, update objects and perform calculations using lamda expressions.</p> <pre><code>ruleStore([\nrule('Flowchart2Body')\n//Notice there is one source and multiple targets\n.in(\"f\", flowchartPk.Flowchart)\n.out(\"b\", htmlPk.B, { //Flowchart's name is turned into bold\nb.value = f.name })\n.out(\"div\", htmlPk.DIV, {\n//A div block contains all model transitions \ndiv.children.addAll(f.transitions) })\n.out(\"body\", htmlPk.BODY, {\n//All flowchart nodes are added to the body\nbody.children.addAll(f.nodes)\n})//Last block of the transformation to be executed\n.endWith({\n//You can access the input object(s)\nbody.text = f.name\n//Similarly, you can access all output object(s)\nbody.children.add(b) body.children.add(div)\n})\n])\n</code></pre> <p>In the transformation example above, one source element <code>f</code> is transformed into multiple targets: <code>b</code> is a <code>Bold</code> HTML element that is assigned the flowchart's name as its value, <code>div</code> output object has all transitions of the flowchart <code>f</code> as its children, and <code>body</code> output object has all flowchart <code>f</code> nodes as its children. Once, all output blocks are executed, the <code>endWith</code> block is invoked. In the <code>endWith</code> block, a lambda expression is defined that updates the <code>body</code> output object's text field with the <code>f</code> flowchart's name and the <code>body</code> object also adds new children: <code>b</code> output object and <code>div</code> output object. These updates are shown in the output, found in the target model.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#rule-priority","title":"Rule Priority","text":"<p>As the title suggests, you can prioritize rules to be executed in the order you prefer using the <code>priority(P)</code> clause where <code>P</code> is a whole number (e.g. 0, 1, 2,...) and the rules are executed in ascending values of <code>P</code> i.e. rules with lower <code>P</code> values have higher priority. </p> <pre><code>ruleStore([\n//Run this rule first\nrule('Flowchart2Title')\n.priority(1)\n.in(\"f\", flowchartPk.Flowchart)\n.out(\"title\", htmlPk.TITLE, {\ntitle.value = f.name }),\n//Run this third\nrule('Action2Heading')\n.priority(3)\n.in(\"a\", flowchartPk.Action)\n.out(\"h2\", htmlPk.H2, {\nh2.value = \"H2 heading for Action: \" + a.name\n}),\n//Run this rule second          \nrule('Decision2Heading')\n.priority(2)\n.in(\"d\", flowchartPk.Decision)\n.out(\"h1\", htmlPk.H1, {\nh1.value = \"H1 heading for Decision: \" + d.name }),\n//Finally run this rule\nrule('Transition2Heading')\n.priority(4)\n.in(\"t\", flowchartPk.Transition)\n.out(\"h3\", htmlPk.H3, {\nh3.value = \"H3 heading for Transition: \" + t.name\n})  ])\n</code></pre> <p>In the MT definition above, the flow of execution for all the rules is:</p> <ol> <li><code>Flowchart2Title</code></li> <li><code>Decision2Heading</code></li> <li><code>Action2Heading</code></li> <li><code>Transition2Heading</code></li> </ol> <p>So you can expect the output of this transformation to also be ordered in the above manner within the target model.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#helpers","title":"Helpers","text":"<p>Helpers offer reusable expressions for rules. They can be used to define static attributes and operations, and contextual operations.</p> <ul> <li>A static attribute is a constant value that can be used in a rule. It is defined using the <code>staticAttribute('&lt;attributeName&gt;', { &lt;attributeValue&gt; })</code> clause. The attribute value can be a primitive value or an <code>EObject</code>. The attribute can be accessed in a rule using the <code>&lt;attributeName&gt;</code> variable. The power of this helper can be displayed using an allInstances(<code>EClass</code>) operation within the helper definition.</li> <li>A static operation is a static method which is defined for the class. It is defined using the <code>staticOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The operation body is a lambda expression that has a list of parameters specified as an arguments map (<code>argMap</code>) which must return a value.  The operation can be accessed in a rule using the <code>&lt;operationName&gt;</code> variable.</li> <li>A contextual operation is a bi-function that allows you to manipulate an argument object (could be an input or output object) and an argument map (which can be passed in between a rule and a helper). This a method invoked on a contextual instance of an object (first argument of the operation). It is defined using the <code>contextualOperation('&lt;operationName&gt;', { &lt;operationBody&gt; })</code> clause. The contextual operation body is a lambda expression that can contain two main arguments. The operation can be accessed in a rule using the <code>c_op</code> variable. The contextual operation is used to access the contextual instance of the input object and it must return either an <code>EObject</code> or a primitive value. The contextual instance is the input object that is matched in the input pattern of the rule. The contextual instance can be accessed in the operation body using the <code>obj</code> variable.</li> </ul> <pre><code>ruleStore([\nrule('Action2Heading')\n.in(\"a\", flowchartPk.Action)\n.out(\"h1\", htmlPk.H1, {\nh1.value = att.toString()\n}),\nrule('Decision2Heading')\n.in(\"d\", flowchartPk.Decision)\n.out(\"h1\", htmlPk.H1, {\n//Call 'op' helper and pass the decision object as a key map\nh1.value = op(['obj': d])\n}),\nrule('Transition2Heading')\n.in(\"t\", flowchartPk.Transition)\n.out(\"h1\", htmlPk.H1, {\n//Call 'c_op' helper and pass the transition object as a key map\n//Also pass a suffix increment argument to the contextual operation\nh1.value = c_op(t, ['suffix': \"_${i++}\"])\n})\n])\nhelperStore([\nstaticAttribute('att', { def actionList = []\nfor (anAction in allInstances(flowchartPk.Action)) {\nactionList.add(anAction.name)\n}\n//returns all instances of Action elements from the source model\nreturn actionList\n}),\nstaticOperation('op', { argsMap -&gt;\n//returns the argument 'obj'\nreturn argsMap.obj.name\n}),\ncontextualOperation('c_op', { obj, argsMap -&gt;\n//returns the name of the contextual instance 'obj' and argument 'suffix'\nreturn obj.name + argsMap['suffix']\n})\n])\n</code></pre> <p>In the example above, all flowchart elements are transformed into <code>H1</code> HTML headings. Within the <code>staticAttribute()</code> helper function, the <code>att</code> attribute returns a list of all instances of <code>Action</code> element in the source model. which is used in the <code>Action2Heading</code> rule. The <code>op</code> static operation returns the name of the <code>Decision</code> object <code>d</code> (passed as the value of a key map) which is used in the <code>Decision2Heading</code> rule. The <code>c_op</code> contextual operation returns the name of the <code>Transition</code> object appended by the value of the <code>suffix</code> argument (<code>i</code> increment counter) which is used in the <code>Transition2Heading</code> rule. This MT definition showcases all types of helpers and how they can be used in rules.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#model-queries","title":"Model Queries","text":"<p>A model query is a rule that has an input pattern and no output pattern. It may have an <code>endWith</code> block to report error messages or compute metrics. The <code>query()</code> clause is used to define a model query. The transformation definition for a model query would look like this:</p> <pre><code>ruleStore([\nrule('Transition')\n.in('t', flowchartPk.Transition)\n.query()\n.endWith{\nprintln(\"processed successfully\")\n}                ])\n</code></pre> <p>Model queries require additional configuration when you execute the YAMTL module:</p> <pre><code>def mm = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore')\ndef query = new Query(mm.contents[0])\nYAMTLGroovyExtensions.init(this)\nquery.selectedExecutionPhases = ExecutionPhase.MATCH_ONLY\nquery.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nquery.execute()\n</code></pre> <p>The <code>selectedExecutionPhases</code> variable is set to <code>MATCH_ONLY</code> to only execute the input pattern of the model query. The <code>loadInputModels()</code> function is used to load the input model. The <code>execute()</code> function is used to execute the model query. The <code>endWith</code> block is executed after the input pattern is matched which outputs a message to the console.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#module-composition","title":"Module Composition","text":"<p>You also have the capability to extend a YAMTL module by inheriting from it. This is called module composition. The <code>extends</code> clause is used to inherit from a YAMTL module. The transformation definition for module composition would look like this:</p> <pre><code>class ModuleComposition extends Inheritance {\npublic ModuleComposition(EPackage flowchartPk, EPackage htmlPk) {\nsuper(flowchartPk, htmlPk)\nruleStore([\nrule('Subflow2H1')\n.inheritsFrom(['Flowchart2H1'])\n.in(\"e\", flowchartPk.Subflow)\n.out(\"h1\", htmlPk.H1, {\nh1.value = \"${h1.value}, where name of subflow is ${e.name}\"\n.toString()                         })\n])\n}}\n</code></pre> <p><code>ModuleComposition</code> module extends the <code>Inheritance</code> module, which allows a rule to inherit from other rule(s) from a different module. The <code>inheritsFrom()</code> clause is used to inherit from a rule. The <code>Subflow2H1</code> rule inherits from the <code>Flowchart2H1</code> rule. The <code>h1</code> output object is updated to a string that contains the value of the <code>h1</code> output object from the <code>Flowchart2H1</code> rule and the name of the <code>Subflow</code> object <code>e</code>. The <code>ModuleComposition</code> module can be executed in the same way as the <code>Inheritance</code> module.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#transformation-test-script","title":"Transformation Test Script","text":"<p>The test script is responsible for loading source and target metamodels, initializing the MT definition, loading soure model into the transformation and executing it, and saving the output in the target model.</p> <pre><code>// model transformation execution\ndef srcRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/flowchart.ecore') def tgtRes = YAMTLModule.preloadMetamodel(BASE_PATH + '/html.ecore')\ndef xform = new &lt;groovyClass&gt;(srcRes.contents[0], tgtRes.contents[0])\nYAMTLGroovyExtensions.init(this)\nxform.loadInputModels(['in': BASE_PATH + '/wakeup.xmi'])\nxform.execute()\nxform.saveOutputModels(['out': BASE_PATH + '/&lt;outputFileName&gt;.xmi'])\n// test assertion\ndef actualModel = xform.getOutputModel('out')\nEMFComparator comparator = new EMFComparator();\n// Load the expected model using the identical output metamodel from the transformation.\n// Essentially, use the same in-memory metamodel.\nxform.loadMetamodelResource(tgtRes) def expectedResource = xform.loadModel(BASE_PATH + '/&lt;expectedOutputFileName&gt;.xmi', false)\ndef assertionResult =  comparator.equals(expectedResource.getContents(), actualModel.getContents()) assertTrue(assertionResult);\n</code></pre> <p>First, both source and target metamodels are each loaded as a resource using a <code>YAMTLModule</code> function called <code>loadMetamodel(&lt;'projectPath'&gt;)</code>. <code>.ecore</code> files and their components are accessed using the <code>resourceName.contents[0]</code> clause. Note that <code>BASE_PATH</code> is just a global variable (with the value 'model' in this case) containing base directory name. <code>xform</code> variable initializes a new MT definition if a valid Groovy class name and parameters (source and target metamodels) are provided. Next, the input model is loaded using project path and the transformation is executed. The output is saved within the target model in the location (path) provided.</p> <p>The test assertion is performed using the <code>EMFComparator</code> package which compares the expected and actual output models. The expected model is loaded from the 'model' directory. The <code>assertionResult</code> variable is a boolean that is true if the expected and actual models are equal. The assertion is performed using the <code>assertTrue()</code> function. In case, the assertion fails, it means the project is not configured correctly or the transformation definition was changed to give a different output.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#development-platforms","title":"Development Platforms","text":"<p>Go to the YAMTL examples GitHub repository and clone it. The root directory is the base of all YAMTL example projects, and you will need to import this directory to configure and build the Gradle project.  You can import the project into an IDE of your choice. The following steps will provide details on how to set up the example project on Eclipse, IntelliJ, and VSCode.</p> <p>YAMTL uses Groovy scripts to define the models and transformations so generally any IDE will need some Groovy support through extensions/plug-ins. Make sure to have YAMTL correctly configured or do the necessary steps found in the YAMTL Workspace Configuration section before you run the project.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#eclipse","title":"Eclipse","text":"<p>In Eclipse, click on <code>File \u2192 Import \u2192 Existing Gradle Projects into Workspace \u2192 Select root directory of the Git repo \u2192 Finish</code>. This will import and load the project in the IDE.</p> <p>Head over to the <code>FlowchartToHTML</code> module within Eclipse, right-click on a test script of your choice in the <code>src/test/groovy</code> folder then <code>Run as \u2192 JUnit Test</code>. Once the test is completed, a new output file (XMI format) will be generated in the <code>model</code> directory. Examine this file.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#intellij","title":"IntelliJ","text":"<p>Within IntelliJ, go to <code>File \u2192 Open</code> and open the project at the root directory of the Git repository.</p> <p>Right-click on <code>src/test/groovy/flowchartToHtmlExamples</code> folder (within the <code>FlowchartToHTML</code> project directory), then 'Run Tests...'. </p> <p>Alternatively, click on the green run button in the top bar which builds the project and generates output files of all transformations in the <code>model</code> directory. </p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#vscode","title":"VSCode","text":"<p>In VSCode, import the project at the root directory of the Git repository by doing <code>File \u2192 Open</code>.</p> <p>After you have imported the <code>FlowchartToHTML</code> project into the workspace, click on the Gradle icon in the left sidebar. Choose, the <code>FlowhchartToHTML</code> project and then perform <code>Tasks \u2192  build \u2192 clean</code>. Do <code>Tasks \u2192 build \u2192 build</code> to build the entire Gradle project (it also runs all test scripts that execute the transformations). </p> <p>Once the project is successfully built, all output files will be generated in the <code>model</code> directory. Examine these files.</p>"},{"location":"tutorials/yamtl-flowchart-to-html.html#references","title":"References","text":"<ul> <li>YAMTL Syntax</li> <li>YAMTL Incremental Support</li> <li>YAMTL Original Documentation</li> </ul>"}]}